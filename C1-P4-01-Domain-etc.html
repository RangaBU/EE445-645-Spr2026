<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiative Transfer - 3D Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 200px;
            font-size: 12px;
        }
        h2 {
            margin: 0 0 10px 0;
            color: #1a1a2e;
            font-size: 16px;
            border-bottom: 2px solid #0f3460;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0 3px 0;
            color: #333;
            font-weight: 600;
            font-size: 12px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin: 6px 0;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #16213e;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        input[type="checkbox"] {
            margin-right: 6px;
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            font-size: 13px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }
        .legend-color {
            width: 30px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 220px;
            font-size: 11px;
            line-height: 1.5;
        }
        .equation {
            background: #f0f0f0;
            padding: 6px;
            border-radius: 4px;
            margin: 6px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        .vector {
            font-weight: bold;
            position: relative;
            display: inline-block;
        }
        .vector.omega::after {
            content: '→';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>Controls</h2>
        <div class="checkbox-container">
            <input type="checkbox" id="showBoundary" checked>
            <label for="showBoundary">Show Boundary δV</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showNormals" checked>
            <label for="showNormals">Show Normal Vectors n⃗</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showIncoming" checked>
            <label for="showIncoming">Show Incoming Particles</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showOutgoing" checked>
            <label for="showOutgoing">Show Outgoing Particles</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showVolume" checked>
            <label for="showVolume">Show Elementary Volume</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showLabels" checked>
            <label for="showLabels">Show All Labels</label>
        </div>
        <button id="resetView">Reset Camera View</button>
        <button id="toggleRotation">Pause Rotation</button>
    </div>

    <div id="info">
        <h2 style="font-size: 14px; margin-top: 0;">Boundary Conditions</h2>
        <div class="equation">
            Incoming: (<span class="vector">n</span> · <span class="vector omega">Ω</span>) < 0
        </div>
        <div class="equation">
            Outgoing: (<span class="vector">n</span> · <span class="vector omega">Ω</span>) > 0
        </div>
        <p style="margin: 8px 0; color: #333; font-size: 11px;">
            where (<span class="vector">n</span> · <span class="vector omega">Ω</span>) = cos(Θ)
        </p>
    </div>

    <div id="legend">
        <h2 style="font-size: 14px; margin-top: 0;">Legend</h2>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(100, 149, 237, 0.3); border: 2px solid #6495ED;"></div>
            <span>Domain V (ellipsoid)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFD700;"></div>
            <span>Boundary δV</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00FF00;"></div>
            <span>Normal vectors <span class="vector">n</span></span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FF3333;"></div>
            <span>Incoming <span class="vector omega">Ω</span> (sphere at base)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #3333FF;"></div>
            <span>Outgoing <span class="vector omega">Ω</span> (sphere at tip)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 165, 0, 0.7); border: 2px solid #FF6600;"></div>
            <span>Elementary Volume dV</span>
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x6495ED, 0.5);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        // Create the main domain V (ellipsoid)
        const domainGeometry = new THREE.SphereGeometry(1, 64, 64);
        domainGeometry.scale(4, 2.5, 3); // Make it an ellipsoid
        const domainMaterial = new THREE.MeshPhongMaterial({
            color: 0x6495ED,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
            wireframe: false
        });
        const domain = new THREE.Mesh(domainGeometry, domainMaterial);
        scene.add(domain);

        // Create boundary δV (wireframe ellipsoid)
        const boundaryGeometry = new THREE.SphereGeometry(1.01, 64, 64);
        boundaryGeometry.scale(4, 2.5, 3);
        const boundaryMaterial = new THREE.LineBasicMaterial({ color: 0xFFD700, linewidth: 2 });
        const boundaryWireframe = new THREE.LineSegments(
            new THREE.EdgesGeometry(boundaryGeometry),
            boundaryMaterial
        );
        scene.add(boundaryWireframe);

        // Create elementary volume (cube) inside the medium - off center
        const cubeGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
        const cubeMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFA500,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const elementaryCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        const cubeEdges = new THREE.LineSegments(
            new THREE.EdgesGeometry(cubeGeometry),
            new THREE.LineBasicMaterial({ color: 0xFF6600, linewidth: 3 })
        );
        elementaryCube.add(cubeEdges);
        elementaryCube.position.set(1.5, -0.5, 1.0); // Off-center position
        scene.add(elementaryCube);

        // Helper function to create text labels with proper vector notation
        function createTextLabel(text, position, color = '#FFFFFF', fontSize = 40) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            // Background for better visibility
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.roundRect(10, 10, canvas.width - 20, canvas.height - 20, 10);
            context.fill();
            
            // For vector symbols, use bold font and draw arrow on top
            if (text.includes('⃗')) {
                const baseText = text.replace('⃗', '');
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                
                // Draw the base character (bold)
                context.fillText(baseText, canvas.width / 2, canvas.height / 2 + 5);
                
                // Measure text width to position arrow
                const textWidth = context.measureText(baseText).width;
                
                // Draw arrow on top
                const arrowX = canvas.width / 2;
                const arrowY = canvas.height / 2 - fontSize * 0.45;
                const arrowWidth = textWidth * 0.8;
                const arrowHeight = fontSize * 0.15;
                
                context.beginPath();
                context.moveTo(arrowX - arrowWidth/2, arrowY);
                context.lineTo(arrowX + arrowWidth/2, arrowY);
                context.strokeStyle = color;
                context.lineWidth = 3;
                context.stroke();
                
                // Arrow head
                context.beginPath();
                context.moveTo(arrowX + arrowWidth/2, arrowY);
                context.lineTo(arrowX + arrowWidth/2 - arrowHeight, arrowY - arrowHeight/2);
                context.lineTo(arrowX + arrowWidth/2 - arrowHeight, arrowY + arrowHeight/2);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            } else {
                // Regular text
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.copy(position);
            
            return sprite;
        }

        // Helper function to create arrows with labels
        function createArrow(origin, direction, length, color) {
            const arrow = new THREE.ArrowHelper(
                direction.normalize(),
                origin,
                length,
                color,
                0.4,
                0.25
            );
            arrow.line.material.linewidth = 3;
            return arrow;
        }

        // Helper function to create particle with sphere at the tip or base
        function createParticleWithSphere(origin, direction, length, color, sphereRadius = 0.15, sphereAtTip = true) {
            const group = new THREE.Group();
            
            // Create arrow
            const arrow = new THREE.ArrowHelper(
                direction.normalize(),
                origin,
                length,
                color,
                0.4,
                0.25
            );
            arrow.line.material.linewidth = 3;
            group.add(arrow);
            
            // Create sphere
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            // Position sphere at the tip or base of the arrow
            let spherePosition;
            if (sphereAtTip) {
                spherePosition = origin.clone().add(direction.clone().normalize().multiplyScalar(length));
            } else {
                // At base (origin of arrow)
                spherePosition = origin.clone();
            }
            sphere.position.copy(spherePosition);
            group.add(sphere);
            
            return group;
        }

        // Create normal vectors at various boundary points on ellipsoid
        const normalVectors = [];
        const normalLabels = [];
        const numNormals = 8;
        for (let i = 0; i < numNormals; i++) {
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = 2 * Math.PI * Math.random();
            
            // Calculate point on ellipsoid surface
            const x = 4 * Math.sin(phi) * Math.cos(theta);
            const y = 2.5 * Math.sin(phi) * Math.sin(theta);
            const z = 3 * Math.cos(phi);
            
            const surfacePoint = new THREE.Vector3(x, y, z);
            
            // Calculate normal for ellipsoid (gradient of implicit function)
            const normalDir = new THREE.Vector3(
                x / (4 * 4),
                y / (2.5 * 2.5),
                z / (3 * 3)
            ).normalize();
            
            const arrow = createArrow(surfacePoint, normalDir, 1.5, 0x00FF00);
            normalVectors.push(arrow);
            scene.add(arrow);
            
            // Add label for some normals
            if (i % 2 === 0) {
                const labelPos = surfacePoint.clone().add(normalDir.clone().multiplyScalar(2.0));
                const label = createTextLabel('n⃗', labelPos, '#00FF00', 50);
                normalLabels.push(label);
                scene.add(label);
            }
        }

        // Create incoming particle vectors (n⃗ · Ω⃗ < 0) with spheres at base
        const incomingParticles = [];
        const incomingLabels = [];
        let incomingCount = 0;
        for (let i = 0; i < 30 && incomingCount < 10; i++) {
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = 2 * Math.PI * Math.random();
            
            // Point on ellipsoid surface
            const x = 4 * Math.sin(phi) * Math.cos(theta);
            const y = 2.5 * Math.sin(phi) * Math.sin(theta);
            const z = 3 * Math.cos(phi);
            
            const boundaryPoint = new THREE.Vector3(x, y, z);
            
            // Normal for ellipsoid
            const normal = new THREE.Vector3(
                x / (4 * 4),
                y / (2.5 * 2.5),
                z / (3 * 3)
            ).normalize();
            
            // Create incoming direction (pointing inward)
            let incomingDir = normal.clone().negate();
            // Add some random variation
            incomingDir.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.4,
                (Math.random() - 0.5) * 0.4,
                (Math.random() - 0.5) * 0.4
            )).normalize();
            
            // Verify it's incoming (dot product < 0)
            if (normal.dot(incomingDir) < 0) {
                // Sphere at base (false parameter)
                const particleGroup = createParticleWithSphere(boundaryPoint, incomingDir, 2.0, 0xFF3333, 0.18, false);
                incomingParticles.push(particleGroup);
                scene.add(particleGroup);
                
                // Add label for some particles
                if (incomingCount % 3 === 0) {
                    const labelPos = boundaryPoint.clone().add(incomingDir.clone().multiplyScalar(2.5));
                    const label = createTextLabel('Ω⃗ (in)', labelPos, '#FF3333', 45);
                    incomingLabels.push(label);
                    scene.add(label);
                }
                incomingCount++;
            }
        }

        // Create outgoing particle vectors (n⃗ · Ω⃗ > 0) with spheres at tip
        const outgoingParticles = [];
        const outgoingLabels = [];
        let outgoingCount = 0;
        for (let i = 0; i < 30 && outgoingCount < 10; i++) {
            const phi = Math.acos(2 * Math.random() - 1);
            const theta = 2 * Math.PI * Math.random();
            
            // Point on ellipsoid surface
            const x = 4 * Math.sin(phi) * Math.cos(theta);
            const y = 2.5 * Math.sin(phi) * Math.sin(theta);
            const z = 3 * Math.cos(phi);
            
            const boundaryPoint = new THREE.Vector3(x, y, z);
            
            // Normal for ellipsoid
            const normal = new THREE.Vector3(
                x / (4 * 4),
                y / (2.5 * 2.5),
                z / (3 * 3)
            ).normalize();
            
            // Create outgoing direction (pointing outward)
            let outgoingDir = normal.clone();
            // Add some random variation
            outgoingDir.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.4,
                (Math.random() - 0.5) * 0.4,
                (Math.random() - 0.5) * 0.4
            )).normalize();
            
            // Verify it's outgoing (dot product > 0)
            if (normal.dot(outgoingDir) > 0) {
                // Sphere at tip (true parameter)
                const particleGroup = createParticleWithSphere(boundaryPoint, outgoingDir, 2.0, 0x3333FF, 0.18, true);
                outgoingParticles.push(particleGroup);
                scene.add(particleGroup);
                
                // Add label for some particles
                if (outgoingCount % 3 === 0) {
                    const labelPos = boundaryPoint.clone().add(outgoingDir.clone().multiplyScalar(2.5));
                    const label = createTextLabel('Ω⃗ (out)', labelPos, '#3333FF', 45);
                    outgoingLabels.push(label);
                    scene.add(label);
                }
                outgoingCount++;
            }
        }

        // Add main labels
        const domainLabel = createTextLabel('Domain V', new THREE.Vector3(0, 3.5, 0), '#6495ED', 60);
        scene.add(domainLabel);
        
        const boundaryLabel = createTextLabel('Boundary δV', new THREE.Vector3(-4.5, 0, 0), '#FFD700', 50);
        scene.add(boundaryLabel);
        
        const volumeLabel = createTextLabel('Elementary Volume dV', 
            new THREE.Vector3(elementaryCube.position.x, elementaryCube.position.y + 1.5, elementaryCube.position.z), 
            '#FFA500', 50);
        scene.add(volumeLabel);
        
        // Control variables
        let rotationEnabled = true;
        const allLabels = [domainLabel, boundaryLabel, volumeLabel, ...normalLabels, ...incomingLabels, ...outgoingLabels];

        // Event listeners
        document.getElementById('showBoundary').addEventListener('change', (e) => {
            boundaryWireframe.visible = e.target.checked;
        });

        document.getElementById('showNormals').addEventListener('change', (e) => {
            normalVectors.forEach(arrow => arrow.visible = e.target.checked);
            normalLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('showIncoming').addEventListener('change', (e) => {
            incomingParticles.forEach(arrow => arrow.visible = e.target.checked);
            incomingLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('showOutgoing').addEventListener('change', (e) => {
            outgoingParticles.forEach(arrow => arrow.visible = e.target.checked);
            outgoingLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('showVolume').addEventListener('change', (e) => {
            elementaryCube.visible = e.target.checked;
            volumeLabel.visible = e.target.checked;
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            allLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);
        });

        document.getElementById('toggleRotation').addEventListener('click', (e) => {
            rotationEnabled = !rotationEnabled;
            e.target.textContent = rotationEnabled ? 'Pause Rotation' : 'Resume Rotation';
        });

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                
                // Rotate camera around the scene
                const radius = camera.position.length();
                const theta = Math.atan2(camera.position.x, camera.position.z);
                const phi = Math.acos(camera.position.y / radius);
                
                const newTheta = theta + deltaX * rotationSpeed;
                const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * rotationSpeed));
                
                camera.position.x = radius * Math.sin(newPhi) * Math.sin(newTheta);
                camera.position.y = radius * Math.cos(newPhi);
                camera.position.z = radius * Math.sin(newPhi) * Math.cos(newTheta);
                camera.lookAt(0, 0, 0);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = camera.position.clone().normalize();
            const distance = e.deltaY * zoomSpeed;
            
            camera.position.add(direction.multiplyScalar(distance));
            
            // Clamp camera distance
            const dist = camera.position.length();
            if (dist < 5) {
                camera.position.normalize().multiplyScalar(5);
            } else if (dist > 20) {
                camera.position.normalize().multiplyScalar(20);
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (rotationEnabled) {
                domain.rotation.y += 0.002;
                boundaryWireframe.rotation.y += 0.002;
            }
            
            // Make labels face camera
            allLabels.forEach(label => {
                label.lookAt(camera.position);
            });
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
