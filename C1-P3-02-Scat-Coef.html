<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photon Scattering in Host Material</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
        }
        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 8px;
        }
        button:hover {
            background: #3a8eef;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>Photon Scattering Visualization</strong><br>
        White spheres: Host material atoms<br>
        Blue photons: Incident light<br>
        Color change: Scattering events<br>
        Yellow flashes: Scattering moments<br>
        <span id="stats">Photons: 0 | Scattered: 0 | Avg Scatterings: 0.00 | ds: 0.00</span>
    </div>
    <div id="controls">
        <button onclick="toggleAnimation()">Pause/Resume</button>
        <button onclick="resetSimulation()">Reset</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let hostAtoms = [];
        let photons = [];
        let scatterFlashes = [];
        let animationRunning = true;
        let photonCount = 0;
        let totalScatterEvents = 0;
        let photonsWithScattering = 0;
        let totalDistanceBeforeScatter = 0;

        // Material box dimensions
        const boxSize = { x: 8, y: 6, z: 4 };
        const numAtoms = 100;
        const scatterProbability = 0.4;
        const photonSpeed = 0.05;
        const spawnRate = 2;

        // Color palette for scattered photons
        const scatterColors = [
            0xff6b6b, // red
            0xffd93d, // yellow
            0x6bcf7f, // green
            0xff8c42, // orange
            0xc77dff, // purple
            0x4ecdc4, // cyan
            0xff006e, // pink
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 0.8);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x6699ff, 0.5);
            pointLight2.position.set(-10, -10, -10);
            scene.add(pointLight2);

            // Create bounding box wireframe
            const boxGeometry = new THREE.BoxGeometry(boxSize.x, boxSize.y, boxSize.z);
            const boxEdges = new THREE.EdgesGeometry(boxGeometry);
            const boxLine = new THREE.LineSegments(
                boxEdges,
                new THREE.LineBasicMaterial({ color: 0x88aaff, transparent: true, opacity: 0.8, linewidth: 2 })
            );
            scene.add(boxLine);

            // Create host atoms (white spheres)
            const atomGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const atomMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0x333333,
                shininess: 30
            });

            for (let i = 0; i < numAtoms; i++) {
                const atom = new THREE.Mesh(atomGeometry, atomMaterial);
                atom.position.x = (Math.random() - 0.5) * boxSize.x;
                atom.position.y = (Math.random() - 0.5) * boxSize.y;
                atom.position.z = (Math.random() - 0.5) * boxSize.z;
                scene.add(atom);
                hostAtoms.push(atom);
            }

            // Window resize handler
            window.addEventListener('resize', onWindowResize, false);
        }

        function createPhoton() {
            // Use single consistent blue color for incident photons
            const incidentBlue = 0x3366ff;
            
            const photonGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const photonMaterial = new THREE.MeshBasicMaterial({ 
                color: incidentBlue,
                transparent: true,
                opacity: 0.9
            });
            
            const photon = new THREE.Mesh(photonGeometry, photonMaterial);
            
            // Start position: outside the box, random y and z
            photon.position.x = -boxSize.x / 2 - 3;
            photon.position.y = (Math.random() - 0.5) * boxSize.y * 0.8;
            photon.position.z = (Math.random() - 0.5) * boxSize.z * 0.8;
            
            // Create a trail effect
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: incidentBlue,
                transparent: true,
                opacity: 0.4
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            
            photon.userData = {
                velocity: new THREE.Vector3(photonSpeed, 0, 0),
                active: true,
                trail: trail,
                trailPositions: [],
                color: incidentBlue,
                scatterCount: 0,
                pathLength: 0,
                distanceSinceLastScatter: 0
            };
            
            scene.add(photon);
            scene.add(trail);
            photons.push(photon);
            photonCount++;
        }

        function createScatterFlash(position) {
            const flashGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff44,
                transparent: true,
                opacity: 1.0
            });
            
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.copy(position);
            flash.userData = { life: 1.0 };
            
            scene.add(flash);
            scatterFlashes.push(flash);
        }

        function scatterPhoton(photon, atom) {
            // Create scatter flash at collision point
            createScatterFlash(photon.position);
            
            // Track distance traveled before this scatter event
            totalDistanceBeforeScatter += photon.userData.distanceSinceLastScatter;
            
            // Increment scatter count
            photon.userData.scatterCount++;
            totalScatterEvents++;
            
            // Reset distance counter for next scattering event
            photon.userData.distanceSinceLastScatter = 0;
            
            // Change color to a random scatter color
            const newColor = scatterColors[Math.floor(Math.random() * scatterColors.length)];
            photon.material.color.setHex(newColor);
            photon.userData.color = newColor;
            photon.userData.trail.material.color.setHex(newColor);
            
            // Calculate new random direction (scattered)
            // We'll scatter in a random direction but with some forward bias
            const theta = (Math.random() - 0.5) * Math.PI * 1.2; // -108째 to +108째
            const phi = Math.random() * Math.PI * 2; // 0째 to 360째
            
            // Convert spherical to Cartesian coordinates
            const speed = photonSpeed;
            photon.userData.velocity.x = speed * Math.cos(theta);
            photon.userData.velocity.y = speed * Math.sin(theta) * Math.sin(phi);
            photon.userData.velocity.z = speed * Math.sin(theta) * Math.cos(phi);
            
            // Clear trail for visual clarity of direction change
            photon.userData.trailPositions = [];
        }

        function checkScattering(photon) {
            for (let atom of hostAtoms) {
                const distance = photon.position.distanceTo(atom.position);
                if (distance < 0.3) { // scattering threshold
                    if (Math.random() < scatterProbability) {
                        scatterPhoton(photon, atom);
                        return true;
                    }
                }
            }
            return false;
        }

        function isInsideBox(position) {
            return position.x > -boxSize.x / 2 && position.x < boxSize.x / 2 &&
                   Math.abs(position.y) < boxSize.y / 2 &&
                   Math.abs(position.z) < boxSize.z / 2;
        }

        function updatePhotons() {
            for (let i = photons.length - 1; i >= 0; i--) {
                const photon = photons[i];
                
                if (!photon.userData.active) continue;
                
                // Store previous position
                const prevPosition = photon.position.clone();
                
                // Move photon
                photon.position.add(photon.userData.velocity);
                
                // Track distances
                const stepDistance = photon.position.distanceTo(prevPosition);
                photon.userData.pathLength += stepDistance;
                photon.userData.distanceSinceLastScatter += stepDistance;
                
                // Update trail
                photon.userData.trailPositions.push(photon.position.clone());
                if (photon.userData.trailPositions.length > 20) {
                    photon.userData.trailPositions.shift();
                }
                
                const positions = new Float32Array(photon.userData.trailPositions.length * 3);
                for (let j = 0; j < photon.userData.trailPositions.length; j++) {
                    positions[j * 3] = photon.userData.trailPositions[j].x;
                    positions[j * 3 + 1] = photon.userData.trailPositions[j].y;
                    positions[j * 3 + 2] = photon.userData.trailPositions[j].z;
                }
                photon.userData.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Check for scattering if inside box
                if (isInsideBox(photon.position)) {
                    checkScattering(photon);
                }
                
                // Remove photon if it exits the box region (with buffer) or has traveled too far
                const exitDistance = Math.max(boxSize.x, boxSize.y, boxSize.z) / 2 + 5;
                if (photon.position.length() > exitDistance || photon.userData.pathLength > 40) {
                    if (photon.userData.scatterCount > 0) {
                        photonsWithScattering++;
                    }
                    scene.remove(photon);
                    scene.remove(photon.userData.trail);
                    photons.splice(i, 1);
                }
            }
        }

        function updateScatterFlashes() {
            for (let i = scatterFlashes.length - 1; i >= 0; i--) {
                const flash = scatterFlashes[i];
                flash.userData.life -= 0.06;
                flash.material.opacity = flash.userData.life;
                flash.scale.set(1 + (1 - flash.userData.life) * 1.5, 
                               1 + (1 - flash.userData.life) * 1.5, 
                               1 + (1 - flash.userData.life) * 1.5);
                
                if (flash.userData.life <= 0) {
                    scene.remove(flash);
                    scatterFlashes.splice(i, 1);
                }
            }
        }

        function updateStats() {
            const avgScattering = photonsWithScattering > 0 ? 
                (totalScatterEvents / photonsWithScattering) : 0;
            const avgDistance = totalScatterEvents > 0 ? 
                (totalDistanceBeforeScatter / totalScatterEvents) : 0;
            document.getElementById('stats').textContent = 
                `Photons: ${photons.length} | Scattered: ${totalScatterEvents} | Avg Scatterings: ${avgScattering.toFixed(2)} | ds: ${avgDistance.toFixed(2)}`;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (animationRunning) {
                // Spawn new photons
                if (Math.random() < 0.4) {
                    for (let i = 0; i < spawnRate; i++) {
                        if (Math.random() < 0.8) createPhoton();
                    }
                }
                
                updatePhotons();
                updateScatterFlashes();
                updateStats();
                
                // Rotate camera slightly for better view
                const time = Date.now() * 0.0001;
                camera.position.x = Math.cos(time) * 12;
                camera.position.z = Math.sin(time) * 12;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }

        function toggleAnimation() {
            animationRunning = !animationRunning;
        }

        function resetSimulation() {
            // Remove all photons
            photons.forEach(photon => {
                scene.remove(photon);
                scene.remove(photon.userData.trail);
            });
            photons = [];
            
            // Remove all flashes
            scatterFlashes.forEach(flash => scene.remove(flash));
            scatterFlashes = [];
            
            photonCount = 0;
            totalScatterEvents = 0;
            photonsWithScattering = 0;
            totalDistanceBeforeScatter = 0;
            updateStats();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>