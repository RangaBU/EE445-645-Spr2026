<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Turbid Medium — Dark Background</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@300&display=swap');
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0c0c10;color:#d4cfc4;font-family:'EB Garamond',Georgia,serif;overflow:hidden;height:100vh;width:100vw}
  #cc{width:100vw;height:100vh;position:relative}
  canvas{display:block}
  #ov{position:absolute;top:24px;left:28px;pointer-events:none;z-index:10}
  #ov h1{font-size:22px;font-weight:600;color:#e8e4d8;letter-spacing:.5px;margin-bottom:4px}
  #ov .sub{font-size:14px;color:#8a8575;font-style:italic}
  #leg{position:absolute;bottom:24px;left:28px;pointer-events:none;z-index:10;
    background:rgba(12,12,16,.88);border:1px solid rgba(200,190,170,.15);border-radius:8px;padding:14px 18px;backdrop-filter:blur(8px)}
  #leg .it{display:flex;align-items:center;gap:10px;margin-bottom:6px;font-size:14px;color:#b0aa9c}
  #leg .it:last-child{margin-bottom:0}
  #leg .sw{width:14px;height:14px;border-radius:3px;flex-shrink:0}
  #leg .m{font-family:'JetBrains Mono',monospace;font-size:13px;color:#d4cfc4}
  #ch{position:absolute;bottom:24px;right:28px;pointer-events:none;z-index:10;font-size:12px;color:#5a5750;text-align:right;line-height:1.6}
</style>
</head>
<body>
<div id="cc">
  <div id="ov">
    <h1>Cylindrical Volume Element ΔV</h1>
    <div class="sub">Leaf shadow projections onto plane dS ⊥ Ω — shadows do not overlap</div>
  </div>
  <div id="leg">
    <div class="it"><div class="sw" style="background:#4a9e5c"></div><span>Leaves — elliptical planar elements inside ΔV</span></div>
    <div class="it"><div class="sw" style="background:rgba(228,180,42,.7)"></div><span class="m">Ω</span><span> — photon travel direction (∥ cylinder axis)</span></div>
    <div class="it"><div class="sw" style="background:#c06030"></div><span>Leaf shadows on plane <span class="m">dS ⊥ Ω</span> (non-overlapping)</span></div>
    <div class="it"><div class="sw" style="background:rgba(200,160,100,.3);border:1px solid rgba(200,160,100,.4)"></div><span>Projection plane <span class="m">dS</span></span></div>
    <div class="it"><div class="sw" style="background:rgba(180,170,150,.25);border:1px solid rgba(180,170,150,.3)"></div><span>Cylinder — <span class="m">ΔV = dS · dξ</span></span></div>
  </div>
  <div id="ch">drag to rotate · scroll to zoom<br>middle-click to pan</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const BG=0x0c0c10;
const LABEL_COLORS={omega:'#ffcc22',dxi:'#66ddff',dS:'#ff9944',dV:'#ff6688'};

const scene=new THREE.Scene();
scene.background=new THREE.Color(BG);
const camera=new THREE.PerspectiveCamera(40,innerWidth/innerHeight,.1,100);
camera.position.set(7,3.5,6);camera.lookAt(0,0,0);
const Rr=new THREE.WebGLRenderer({antialias:true});
Rr.setSize(innerWidth,innerHeight);Rr.setPixelRatio(Math.min(devicePixelRatio,2));
document.getElementById('cc').appendChild(Rr.domElement);

// Orbit
class OC{constructor(c,e){this.c=c;this.e=e;this.t=new THREE.Vector3();this.s=new THREE.Spherical();
this.dr=false;this.pa=false;this.l={x:0,y:0};this.s.setFromVector3(c.position.clone().sub(this.t));
e.addEventListener('mousedown',v=>{if(v.button===0){this.dr=true;this.pa=false}else{this.pa=true;this.dr=false}this.l={x:v.clientX,y:v.clientY}});
e.addEventListener('mousemove',v=>{if(!this.dr&&!this.pa)return;const dx=v.clientX-this.l.x,dy=v.clientY-this.l.y;this.l={x:v.clientX,y:v.clientY};
if(this.dr){this.s.theta-=dx*.004;this.s.phi-=dy*.004;this.s.phi=Math.max(.1,Math.min(Math.PI-.1,this.s.phi))}
else{const r=new THREE.Vector3(),u=new THREE.Vector3();r.setFromMatrixColumn(this.c.matrix,0);u.setFromMatrixColumn(this.c.matrix,1);
this.t.addScaledVector(r,-dx*.001*this.s.radius);this.t.addScaledVector(u,dy*.001*this.s.radius)}this.u()});
e.addEventListener('mouseup',()=>{this.dr=false;this.pa=false});e.addEventListener('mouseleave',()=>{this.dr=false;this.pa=false});
e.addEventListener('wheel',v=>{v.preventDefault();this.s.radius*=v.deltaY>0?1.08:.92;this.s.radius=Math.max(2,Math.min(30,this.s.radius));this.u()},{passive:false});
e.addEventListener('contextmenu',v=>v.preventDefault());
e.addEventListener('touchstart',v=>{v.preventDefault();if(v.touches.length===1){this.dr=true;this.l={x:v.touches[0].clientX,y:v.touches[0].clientY}}
else if(v.touches.length===2){this.dr=false;this._p=Math.hypot(v.touches[0].clientX-v.touches[1].clientX,v.touches[0].clientY-v.touches[1].clientY)}},{passive:false});
e.addEventListener('touchmove',v=>{v.preventDefault();if(v.touches.length===1&&this.dr){const dx=v.touches[0].clientX-this.l.x,dy=v.touches[0].clientY-this.l.y;
this.l={x:v.touches[0].clientX,y:v.touches[0].clientY};this.s.theta-=dx*.004;this.s.phi-=dy*.004;this.s.phi=Math.max(.1,Math.min(Math.PI-.1,this.s.phi));this.u()}
else if(v.touches.length===2){const dd=Math.hypot(v.touches[0].clientX-v.touches[1].clientX,v.touches[0].clientY-v.touches[1].clientY);
this.s.radius*=this._p/dd;this.s.radius=Math.max(2,Math.min(30,this.s.radius));this._p=dd;this.u()}},{passive:false});
e.addEventListener('touchend',()=>this.dr=false)}
u(){const o=new THREE.Vector3().setFromSpherical(this.s);this.c.position.copy(this.t).add(o);this.c.lookAt(this.t)}}
new OC(camera,Rr.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xb0a890,.55));
const dl=new THREE.DirectionalLight(0xfff5e0,.85);dl.position.set(4,9,5);scene.add(dl);
const rl=new THREE.DirectionalLight(0x6688aa,.25);rl.position.set(-4,2,-5);scene.add(rl);

const G=new THREE.Group();
G.rotation.set(.45,0,-.3);
scene.add(G);

const CR=1.3,CH=2.8,NL=20;

// Cylinder
G.add(new THREE.Mesh(new THREE.CylinderGeometry(CR,CR,CH,48,1,true),
  new THREE.MeshPhysicalMaterial({color:0xb0a890,transparent:true,opacity:.11,side:THREE.DoubleSide,roughness:.8,depthWrite:false})));

function mkRing(y,c){const p=[];for(let i=0;i<=64;i++){const a=i/64*Math.PI*2;p.push(new THREE.Vector3(Math.cos(a)*CR,y,Math.sin(a)*CR))}
return new THREE.Line(new THREE.BufferGeometry().setFromPoints(p),new THREE.LineBasicMaterial({color:c,transparent:true,opacity:.5}))}
G.add(mkRing(CH/2,0x999080));G.add(mkRing(-CH/2,0x999080));
for(let i=0;i<10;i++){const a=i/10*Math.PI*2,x=Math.cos(a)*CR,z=Math.sin(a)*CR;
G.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x,-CH/2,z),new THREE.Vector3(x,CH/2,z)]),
new THREE.LineBasicMaterial({color:0x888070,transparent:true,opacity:.15})))}

// Leaves
const seed=(s)=>{let h=s;return()=>{h=Math.imul(h^(h>>>16),0x45d9f3b);h=Math.imul(h^(h>>>13),0x45d9f3b);return((h^(h>>>16))>>>0)/4294967296}};
const rng=seed(42);
const lerp=(a,b,t)=>a+(b-a)*t;
const leafData=[];
for(let i=0;i<NL;i++){
  const angle=rng()*Math.PI*2,radius=Math.sqrt(rng())*CR*.85;
  const x=Math.cos(angle)*radius,z=Math.sin(angle)*radius,y=lerp(-CH/2+.15,CH/2-.15,rng());
  const rx=lerp(-.8,.8,rng()),ry=rng()*Math.PI*2,rz=lerp(-.6,.6,rng());
  const sx=lerp(.18,.34,rng()),sy=lerp(.10,.20,rng());
  leafData.push({x,y,z,rx,ry,rz,sx,sy});
}
const LC=[0x2e8a3c,0x3ca55e,0x1f7a3f,0x4db870,0x3d9050,0x468c52,0x388040,0x509858,0x2d7535,0x43a050,
          0x35944a,0x5ab86c,0x2a8040,0x48a558,0x3b9448,0x55b862,0x308838,0x4ca05a,0x2c7a34,0x42984e];
const leaves=[];
leafData.forEach((d,i)=>{
  const sh=new THREE.Shape();
  for(let j=0;j<=32;j++){const a=j/32*Math.PI*2;
  if(j===0)sh.moveTo(Math.cos(a)*d.sx,Math.sin(a)*d.sy);else sh.lineTo(Math.cos(a)*d.sx,Math.sin(a)*d.sy)}
  const m=new THREE.Mesh(new THREE.ShapeGeometry(sh),
    new THREE.MeshStandardMaterial({color:LC[i%LC.length],side:THREE.DoubleSide,roughness:.6,metalness:.05}));
  m.position.set(d.x,d.y,d.z);m.rotation.set(d.rx,d.ry,d.rz);G.add(m);
  const vg=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-d.sx*.7,0,.002),new THREE.Vector3(d.sx*.7,0,.002)]);
  const v=new THREE.Line(vg,new THREE.LineBasicMaterial({color:0x1e5528,transparent:true,opacity:.4}));
  v.position.copy(m.position);v.rotation.copy(m.rotation);G.add(v);
  leaves.push({m,d});
});

// Shadow plane
const SY=-CH/2-2.2;
const discMat=new THREE.MeshStandardMaterial({color:0xc8a050,transparent:true,opacity:.13,side:THREE.DoubleSide,roughness:1,depthWrite:false});
const disc=new THREE.Mesh(new THREE.CylinderGeometry(CR*1.4,CR*1.4,.01,48),discMat);
disc.position.y=SY;G.add(disc);
const rp=[];for(let i=0;i<=64;i++){const a=i/64*Math.PI*2;rp.push(new THREE.Vector3(Math.cos(a)*CR*1.4,SY,Math.sin(a)*CR*1.4))}
G.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(rp),
  new THREE.LineBasicMaterial({color:0xc89848,transparent:true,opacity:.55})));

// Shadows — non-overlapping Vogel spiral
const SP=[];
const golden=Math.PI*(3-Math.sqrt(5));
for(let i=0;i<NL;i++){const r_f=.58*Math.sqrt((i+.5)/NL)*CR,th=i*golden;SP.push({x:r_f*Math.cos(th),z:r_f*Math.sin(th)})}
const SC=[0xb84c20,0xc45828,0xa84018,0xd06030,0xbc5024,0xc85c2c,0xb04820,0xcc5830,0xa44018,0xd46434,
          0xb84c22,0xc05426,0xac441a,0xd25e2e,0xb84e24,0xc4582a,0xb04a1e,0xc85a2e,0xa8421a,0xd06230];
leaves.forEach((lo,i)=>{
  const d=lo.d,sp=SP[i],srx=d.sx*.55,sry=d.sy*.55;
  const sh=new THREE.Shape();
  for(let j=0;j<=32;j++){const a=j/32*Math.PI*2;
  if(j===0)sh.moveTo(Math.cos(a)*srx,Math.sin(a)*sry);else sh.lineTo(Math.cos(a)*srx,Math.sin(a)*sry)}
  const sm=new THREE.Mesh(new THREE.ShapeGeometry(sh),
    new THREE.MeshBasicMaterial({color:SC[i%SC.length],transparent:true,opacity:.7,side:THREE.DoubleSide,depthWrite:false}));
  sm.rotation.x=-Math.PI/2;sm.rotation.z=d.ry*.4;
  sm.position.set(sp.x,SY+.015,sp.z);G.add(sm);
  const lg=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(d.x,d.y,d.z),new THREE.Vector3(sp.x,SY,sp.z)]);
  const ll=new THREE.Line(lg,new THREE.LineDashedMaterial({color:0xc89848,transparent:true,opacity:.18,dashSize:.08,gapSize:.06}));
  ll.computeLineDistances();G.add(ll);
});

// Omega arrows
const ac=0xe4b42a;
const beams=[];
for(let gx=-3;gx<=3;gx++){for(let gz=-3;gz<=3;gz++){const bx=gx*.3,bz=gz*.3;if(bx*bx+bz*bz<CR*CR*.7)beams.push([bx,bz])}}
beams.forEach(([ox,oz])=>{
  const ar=new THREE.ArrowHelper(new THREE.Vector3(0,-1,0),new THREE.Vector3(ox,CH/2+1.8,oz),1.5,ac,.18,.09);
  ar.children.forEach(c=>{if(c.material){c.material.transparent=true;c.material.opacity=.7}});G.add(ar);
});

// LABELS — large, bold, high-contrast colors
function lbl(text,pos,fontSize,color,scale){
  const cv=document.createElement('canvas');cv.width=1024;cv.height=512;
  const cx=cv.getContext('2d');cx.clearRect(0,0,1024,512);
  // Bold text with glow/outline for readability
  cx.font=`bold ${fontSize||72}px "EB Garamond",Georgia,serif`;
  cx.textAlign='center';cx.textBaseline='middle';
  // Shadow/glow for contrast
  cx.shadowColor='rgba(0,0,0,0.8)';cx.shadowBlur=12;cx.shadowOffsetX=0;cx.shadowOffsetY=0;
  cx.fillStyle=color||'#ffffff';
  cx.fillText(text,512,256);
  // Second pass for extra boldness
  cx.shadowBlur=0;
  cx.fillText(text,512,256);
  const tx=new THREE.CanvasTexture(cv);tx.needsUpdate=true;
  const s=new THREE.Sprite(new THREE.SpriteMaterial({map:tx,transparent:true,depthTest:false}));
  s.position.copy(pos);s.scale.set((scale||1)*2.8,(scale||1)*1.4,1);return s}

G.add(lbl('Ω',new THREE.Vector3(.15,CH/2+2.8,0),110,LABEL_COLORS.omega,1.3));
G.add(lbl('dξ',new THREE.Vector3(-CR-1.2,0,0),90,LABEL_COLORS.dxi,1.1));
G.add(lbl('dS',new THREE.Vector3(CR*1.7+.3,SY+.05,.3),85,LABEL_COLORS.dS,1.0));
G.add(lbl('ΔV = dS · dξ',new THREE.Vector3(CR+2.0,CH/2+.5,0),68,LABEL_COLORS.dV,1.2));

// dξ bracket
const bx=-CR-.5;
const bm=new THREE.LineBasicMaterial({color:0x66ddff,transparent:true,opacity:.6});
G.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(bx,-CH/2,0),new THREE.Vector3(bx,CH/2,0)]),bm));
[-CH/2,CH/2].forEach(y=>G.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(
  [new THREE.Vector3(bx-.12,y,0),new THREE.Vector3(bx+.12,y,0)]),bm.clone())));
[{y:CH/2,d:1},{y:-CH/2,d:-1}].forEach(({y,d})=>{const s=.1;
G.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(
  [new THREE.Vector3(bx-s,y-d*s*1.5,0),new THREE.Vector3(bx,y,0),new THREE.Vector3(bx+s,y-d*s*1.5,0)]),bm.clone()))});

// Ground grid
const gr=new THREE.GridHelper(14,28,0x1a1a28,0x141420);
gr.position.y=-5.5;gr.material.transparent=true;gr.material.opacity=.2;scene.add(gr);

(function a(){requestAnimationFrame(a);Rr.render(scene,camera)})();
addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();Rr.setSize(innerWidth,innerHeight)});
</script>
</body>
</html>
