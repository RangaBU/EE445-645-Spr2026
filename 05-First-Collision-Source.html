<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First-Collision Source Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border: 1px solid orange;
            border-radius: 5px;
            font-size: 12px;
        }
        #info h3 {
            margin: 0 0 10px 0;
            color: orange;
        }
        #info div {
            margin: 5px 0;
        }
        .color-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        .label {
            position: absolute;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            border: 1px solid;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <h3>First-Collision Source Q¹(r̂,Ω)</h3>
        <div><span class="color-box" style="background: orange;"></span> Boundary Surface</div>
        <div><span class="color-box" style="background: white;"></span> Host Material</div>
        <div><span class="color-box" style="background: cyan;"></span> Incoming Direction Ω'</div>
        <div><span class="color-box" style="background: red;"></span> Scattering Point r̂</div>
        <div><span class="color-box" style="background: orange;"></span> Scattered Direction Ω</div>
        <div><span class="color-box" style="background: #0055ff;"></span> Photons (animated)</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-8, 2, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);

        // CSS2D Renderer for labels
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('container').appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Enhanced Lighting for better sphere appearance
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight1.position.set(10, 10, 10);
        directionalLight1.castShadow = true;
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight2.position.set(-10, -10, -10);
        scene.add(directionalLight2);

        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(0, 5, 0);
        scene.add(pointLight);

        // Ellipsoid parameters
        const a = 3, b = 2, c = 1.5;

        // Create 3D MESH GRID with VISIBLE LINES
        // Meridian lines (longitude)
        const numMeridians = 24;
        for (let i = 0; i < numMeridians; i++) {
            const theta = (i / numMeridians) * Math.PI * 2;
            const points = [];
            for (let j = 0; j <= 50; j++) {
                const phi = (j / 50) * Math.PI;
                const x = a * Math.sin(phi) * Math.cos(theta);
                const y = b * Math.sin(phi) * Math.sin(theta);
                const z = c * Math.cos(phi);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff8800,
                linewidth: 1
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        // Parallel lines (latitude)
        const numParallels = 16;
        for (let j = 0; j <= numParallels; j++) {
            const phi = (j / numParallels) * Math.PI;
            const points = [];
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                const x = a * Math.sin(phi) * Math.cos(theta);
                const y = b * Math.sin(phi) * Math.sin(theta);
                const z = c * Math.cos(phi);
                points.push(new THREE.Vector3(x, y, z));
            }
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff8800,
                linewidth: 1
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        // Transparent ellipsoid surface (very subtle)
        const ellipsoidGeometry = new THREE.SphereGeometry(1, 32, 24);
        ellipsoidGeometry.scale(a, b, c);
        const ellipsoidMaterial = new THREE.MeshBasicMaterial({
            color: 0xff8800,
            transparent: true,
            opacity: 0.05,
            side: THREE.DoubleSide
        });
        const ellipsoid = new THREE.Mesh(ellipsoidGeometry, ellipsoidMaterial);
        scene.add(ellipsoid);

        // Host material particles - ULTRA WHITE SOLID SPHERES
        const particleGeometry = new THREE.SphereGeometry(0.09, 24, 24);
        const particleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff,
            metalness: 0.0,
            roughness: 0.3,
            emissive: 0xffffff,
            emissiveIntensity: 0.4
        });
        
        for (let i = 0; i < 100; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = Math.pow(Math.random(), 1/3) * 0.85;
            
            const x = r * a * Math.sin(phi) * Math.cos(theta);
            const y = r * b * Math.sin(phi) * Math.sin(theta);
            const z = r * c * Math.cos(phi);
            
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.set(x, y, z);
            particle.castShadow = true;
            particle.receiveShadow = true;
            scene.add(particle);
        }

        // Scattering point positions - DEEPER IN THE MEDIUM
        const theta_B = Math.PI / 4;
        const phi_B = Math.PI / 3;
        const r_B = new THREE.Vector3(
            a * Math.sin(phi_B) * Math.cos(theta_B),
            b * Math.sin(phi_B) * Math.sin(theta_B),
            c * Math.cos(phi_B)
        );
        
        // Extended boundary point
        const r_B_extended = r_B.clone().multiplyScalar(1.8);
        
        // Scattering point DEEPER in medium
        const r_interior = new THREE.Vector3(0.3, 0.2, 0.1);
        
        // Scattered direction
        const omega = new THREE.Vector3(0.3, 0.2, -0.5).normalize();
        const scatter_end = r_interior.clone().add(omega.clone().multiplyScalar(6));

        // Scattering point (red) - glowing sphere
        const scatterPointGeometry = new THREE.SphereGeometry(0.2, 24, 24);
        const scatterPointMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xff0000, 
            emissive: 0xff0000, 
            emissiveIntensity: 0.9,
            metalness: 0.1,
            roughness: 0.2
        });
        const scatterPoint = new THREE.Mesh(scatterPointGeometry, scatterPointMaterial);
        scatterPoint.position.copy(r_interior);
        scene.add(scatterPoint);

        // Label for scattering point
        const rLabel = document.createElement('div');
        rLabel.className = 'label';
        rLabel.textContent = 'r̂';
        rLabel.style.color = '#ff0000';
        rLabel.style.borderColor = '#ff0000';
        const rLabelObj = new CSS2DObject(rLabel);
        rLabelObj.position.set(0, 0.4, 0);
        scatterPoint.add(rLabelObj);

        // Incoming direction line (cyan dashed)
        const incomingPoints = [r_B_extended, r_interior];
        const incomingGeometry = new THREE.BufferGeometry().setFromPoints(incomingPoints);
        const incomingMaterial = new THREE.LineDashedMaterial({ 
            color: 0x00ffff, 
            linewidth: 3,
            dashSize: 0.3,
            gapSize: 0.15
        });
        const incomingLine = new THREE.Line(incomingGeometry, incomingMaterial);
        incomingLine.computeLineDistances();
        scene.add(incomingLine);

        // Label for incoming direction
        const incomingLabelDiv = document.createElement('div');
        incomingLabelDiv.className = 'label';
        incomingLabelDiv.textContent = "Incoming Ω'";
        incomingLabelDiv.style.color = '#00ffff';
        incomingLabelDiv.style.borderColor = '#00ffff';
        const incomingLabel = new CSS2DObject(incomingLabelDiv);
        const incomingMidpoint = r_B_extended.clone().lerp(r_interior, 0.5);
        incomingLabel.position.copy(incomingMidpoint);
        scene.add(incomingLabel);

        // Scattering sphere with ARROWS - tips form a sphere
        const numArrows = 16;
        const arrowRadius = 1.0;
        
        for (let i = 0; i < numArrows; i++) {
            // Fibonacci sphere distribution for even spacing
            const phi = Math.acos(1 - 2 * (i + 0.5) / numArrows);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);
            
            const dir = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            );
            
            // Arrow starts at scattering point, tip at sphere surface
            const arrowHelper = new THREE.ArrowHelper(
                dir,
                r_interior,
                arrowRadius,
                0x888888,
                0.15,
                0.1
            );
            arrowHelper.line.material.transparent = true;
            arrowHelper.line.material.opacity = 0.4;
            arrowHelper.cone.material.transparent = true;
            arrowHelper.cone.material.opacity = 0.5;
            scene.add(arrowHelper);
        }

        // Main scattered direction (ORANGE ARROW)
        const scatteredArrow = new THREE.ArrowHelper(
            omega,
            r_interior,
            6,
            0xff8800,
            0.3,
            0.2
        );
        scatteredArrow.line.material.linewidth = 3;
        scene.add(scatteredArrow);

        // Label for scattered direction
        const scatteredLabelDiv = document.createElement('div');
        scatteredLabelDiv.className = 'label';
        scatteredLabelDiv.textContent = 'Scattered Ω';
        scatteredLabelDiv.style.color = '#ff8800';
        scatteredLabelDiv.style.borderColor = '#ff8800';
        const scatteredLabel = new CSS2DObject(scatteredLabelDiv);
        const scatteredMidpoint = r_interior.clone().lerp(scatter_end, 0.5);
        scatteredLabel.position.copy(scatteredMidpoint);
        scene.add(scatteredLabel);

        // Animated photons - SMALLER and MORE BLUE
        const photonGeometry = new THREE.SphereGeometry(0.08, 16, 16); // Reduced from 0.14 to 0.08
        const photonMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0055ff,  // More saturated blue (was 0x0088ff)
            emissive: 0x0055ff, 
            emissiveIntensity: 1.5,  // Increased for more vibrant blue glow
            metalness: 0.1,
            roughness: 0.1
        });

        const incomingPhotons = [];
        const scatteredPhotons = [];
        const numPhotons = 5;

        for (let i = 0; i < numPhotons; i++) {
            const photon = new THREE.Mesh(photonGeometry, photonMaterial);
            scene.add(photon);
            incomingPhotons.push(photon);
        }

        for (let i = 0; i < numPhotons; i++) {
            const photon = new THREE.Mesh(photonGeometry, photonMaterial);
            scene.add(photon);
            scatteredPhotons.push(photon);
        }

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.008;
            const t = (time % 1);
            
            // Update incoming photons
            for (let i = 0; i < numPhotons; i++) {
                const offset = i / numPhotons;
                const photon_t = (t + offset) % 1;
                
                const pos = r_B_extended.clone().lerp(r_interior, photon_t);
                incomingPhotons[i].position.copy(pos);
            }
            
            // Update scattered photons
            for (let i = 0; i < numPhotons; i++) {
                const offset = i / numPhotons;
                const photon_t = (t + offset) % 1;
                
                const pos = r_interior.clone().lerp(scatter_end, photon_t);
                scatteredPhotons[i].position.copy(pos);
            }
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
