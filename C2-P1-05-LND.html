<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Leaf Normal Distribution (Dark) — gL(ΩL)</title>
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    min-height: 100vh;
    background: #0a0a0f;
    font-family: 'EB Garamond', Georgia, 'Times New Roman', serif;
    padding: 32px 20px;
    display: flex;
    justify-content: center;
  }
  .container { max-width: 960px; width: 100%; }
  .header { text-align: center; margin-bottom: 28px; }
  .header h1 { font-size: 32px; font-weight: 700; color: #e8ecf0; letter-spacing: -0.02em; line-height: 1.2; }
  .header .subtitle { font-size: 17px; color: #c0cad8; margin-top: 8px; font-style: italic; max-width: 520px; margin-left: auto; margin-right: auto; }
  .header .equation-box {
    margin-top: 10px; font-size: 13px; color: #e8ecf0;
    font-family: 'JetBrains Mono', monospace;
    background: #161620; display: inline-block; padding: 6px 16px;
    border-radius: 6px; border: 1px solid #2a2a3a;
  }
  .mono { font-family: 'JetBrains Mono', monospace; font-size: 14px; }
  .main-layout { display: flex; gap: 20px; flex-wrap: wrap; }
  .panel {
    background: #161620; border-radius: 14px; border: 1px solid #2a2a3a;
    padding: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  }
  .panel-left { flex: 1 1 480px; }
  .panel-right { flex: 1 1 300px; display: flex; flex-direction: column; gap: 16px; }
  .section-label {
    font-size: 13px; font-weight: 600; color: #e8ecf0; margin-bottom: 10px;
    font-family: 'JetBrains Mono', monospace; text-transform: uppercase; letter-spacing: 0.08em;
  }
  .dist-buttons { display: flex; flex-wrap: wrap; gap: 6px; }
  .dist-btn {
    padding: 7px 14px; font-size: 13px; font-weight: 600;
    font-family: 'EB Garamond', Georgia, serif;
    border: 1.5px solid #3a3a4a; border-radius: 8px;
    background: #1e1e2a; color: #c0cad8; cursor: pointer; transition: all 0.2s;
  }
  .dist-btn.active { border-width: 2px; }
  .dist-desc { font-size: 13px; color: #e8ecf0; margin-top: 8px; font-style: italic; }
  .angle-row { margin-bottom: 14px; }
  .angle-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 4px; }
  .angle-label { font-size: 15px; color: #c0cad8; }
  .angle-value { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600; }
  .angle-range { width: 100%; }
  .range-labels { display: flex; justify-content: space-between; font-size: 10px; color: #c0cad8; font-family: 'JetBrains Mono', monospace; }
  .animate-btn {
    width: 100%; padding: 9px 0; font-size: 14px;
    font-family: 'EB Garamond', Georgia, serif; font-weight: 600;
    border-radius: 8px; cursor: pointer; transition: all 0.2s;
  }
  .footer-eq {
    text-align: center; margin-top: 24px; padding: 14px 20px;
    background: #161620; border-radius: 10px; border: 1px solid #2a2a3a;
    font-size: 13px; color: #c0cad8;
    font-family: 'JetBrains Mono', monospace;
    box-shadow: 0 2px 12px rgba(0,0,0,0.25);
  }
  svg { display: block; }
</style>
</head>
<body>

<div class="container">
  <!-- Header -->
  <div class="header">
    <h1>Leaf Normal Distribution</h1>
    <p class="subtitle">
      The function <span class="mono">ḡ<sub>L</sub>(<b>&Omega;</b><sub>L</sub>) / 2&pi;</span>
      describes the probability density of leaf normal orientation on the upper hemisphere
    </p>
    <div class="equation-box">
      &int;<sub>2&pi;+</sub> ḡ<sub>L</sub>(<b>&Omega;</b><sub>L</sub>) d<b>&Omega;</b><sub>L</sub> = 1
      &nbsp;&nbsp;where&nbsp;&nbsp; <b>&Omega;</b><sub>L</sub> = (&theta;<sub>L</sub>, &phi;<sub>L</sub>)
    </div>
  </div>

  <!-- Main layout -->
  <div class="main-layout">
    <!-- Left: 3D Hemisphere -->
    <div class="panel panel-left">
      <div class="section-label" style="margin-bottom:4px">3D Hemisphere View</div>
      <svg id="hemiSvg" viewBox="0 0 520 460" style="width:100%;height:auto;"></svg>
    </div>

    <!-- Right: Controls + Polar -->
    <div class="panel-right">
      <!-- Distribution selector -->
      <div class="panel">
        <div class="section-label">Distribution Type</div>
        <div class="dist-buttons" id="distButtons"></div>
        <p class="dist-desc" id="distDesc"></p>
      </div>

      <!-- Angle controls -->
      <div class="panel">
        <div class="section-label">Leaf Normal Angles</div>
        <div class="angle-row">
          <div class="angle-header">
            <span class="angle-label">Zenith angle &theta;<sub>L</sub></span>
            <span class="angle-value" id="thetaVal"></span>
          </div>
          <input type="range" class="angle-range" id="thetaSlider" min="0" max="90" value="35">
          <div class="range-labels"><span>0&deg; (vertical)</span><span>90&deg; (horizontal)</span></div>
        </div>
        <div class="angle-row">
          <div class="angle-header">
            <span class="angle-label">Azimuth angle &phi;<sub>L</sub></span>
            <span class="angle-value" id="phiVal"></span>
          </div>
          <input type="range" class="angle-range" id="phiSlider" min="0" max="360" value="40">
          <div class="range-labels"><span>0&deg;</span><span>360&deg;</span></div>
        </div>
        <button class="animate-btn" id="animateBtn">&#9654; Animate &theta; Sweep</button>
      </div>

      <!-- Polar plot -->
      <div class="panel">
        <svg id="polarSvg" viewBox="0 0 280 340" style="width:100%;height:auto;"></svg>
      </div>
    </div>
  </div>

  <!-- Footer equation -->
  <div class="footer-eq">
    For azimuthally symmetric distributions: &nbsp;
    ḡ<sub>L</sub>(<b>&Omega;</b><sub>L</sub>) = ḡ<sub>L</sub>(&theta;<sub>L</sub>) &nbsp;&middot;&nbsp;
    &int;<sub>0</sub><sup>&pi;/2</sup> ḡ<sub>L</sub>(&theta;<sub>L</sub>) sin(&theta;<sub>L</sub>) d&theta;<sub>L</sub> = 1
  </div>
</div>

<script>
const TAU = Math.PI * 2;
const PI = Math.PI;

// ── Distributions (de Wit, 1965) ──
const distributions = {
  spherical:    { label:"Spherical",    desc:"Leaves oriented uniformly in all directions",    fn: t => Math.sin(t),                          color:"#7FD992" },
  planophile:   { label:"Planophile",   desc:"Leaves predominantly horizontal",                fn: t => (2/PI)*(1+Math.cos(2*t)),              color:"#5EC0E8" },
  erectophile:  { label:"Erectophile",  desc:"Leaves predominantly vertical",                  fn: t => (2/PI)*(1-Math.cos(2*t)),              color:"#F09070" },
  plagiophile:  { label:"Plagiophile",  desc:"Leaves predominantly at 45\u00B0",               fn: t => (2/PI)*(1-Math.cos(4*t)),              color:"#B89EE0" },
  extremophile: { label:"Extremophile", desc:"Leaves at 0\u00B0 or 90\u00B0, few at 45\u00B0", fn: t => (2/PI)*(1+Math.cos(4*t)),              color:"#E8C860" },
  uniform:      { label:"Uniform",      desc:"Equal probability at all zenith angles",          fn: () => 2/PI,                                 color:"#A8A8B0" },
};
const distKeys = Object.keys(distributions);

// ── State ──
let currentDist = "spherical";
let thetaDeg = 35, phiDeg = 40;
let animating = false, animId = null;

// ── 3D Projection ──
function rotY(x,y,z,a){ return [x*Math.cos(a)+z*Math.sin(a), y, -x*Math.sin(a)+z*Math.cos(a)]; }
function rotX(x,y,z,a){ return [x, y*Math.cos(a)-z*Math.sin(a), y*Math.sin(a)+z*Math.cos(a)]; }
function proj(x,y,z, rX,rY, sc, cx,cy){
  let [x1,y1,z1] = rotY(x,y,z,rY);
  [x1,y1,z1] = rotX(x1,y1,z1,rX);
  const per = 4/(4 - z1*0.3);
  return { x: cx+x1*sc*per, y: cy-y1*sc*per, z: z1 };
}

// ── SVG helpers ──
function svgEl(tag, attrs, parent){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for(const [k,v] of Object.entries(attrs||{})) el.setAttribute(k,v);
  if(parent) parent.appendChild(el);
  return el;
}
function clearSvg(svg){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

// ── Draw Hemisphere ──
function drawHemisphere(){
  const svg = document.getElementById("hemiSvg");
  clearSvg(svg);
  const W=520, H=460, cx=W/2, cy=H/2+40, R=140, sc=R;
  const rX=-0.35, rY=0.45;
  const p = (x,y,z) => proj(x,y,z,rX,rY,sc,cx,cy);

  const dd = distributions[currentDist];
  const thetaL = thetaDeg/180*PI, phiL = phiDeg/180*PI;
  const gVal = dd.fn(thetaL);
  const nlx=Math.sin(thetaL)*Math.cos(phiL), nly=Math.sin(thetaL)*Math.sin(phiL), nlz=Math.cos(thetaL);

  // Defs
  const defs = svgEl("defs",{},svg);
  // Radial gradient
  const rg = svgEl("radialGradient",{id:"hemiGlow",cx:"40%",cy:"35%",r:"60%"},defs);
  svgEl("stop",{offset:"0%","stop-color":dd.color,"stop-opacity":"0.12"},rg);
  svgEl("stop",{offset:"100%","stop-color":dd.color,"stop-opacity":"0.02"},rg);
  // Arrow markers
  const m1 = svgEl("marker",{id:"arrowN",markerWidth:"10",markerHeight:"7",refX:"9",refY:"3.5",orient:"auto"},defs);
  svgEl("polygon",{points:"0 0, 10 3.5, 0 7",fill:dd.color},m1);
  const m2 = svgEl("marker",{id:"arrowZ",markerWidth:"8",markerHeight:"6",refX:"7",refY:"3",orient:"auto"},defs);
  svgEl("polygon",{points:"0 0, 8 3, 0 6",fill:"#e0e6ee"},m2);
  // Leaf gradient
  const lg = svgEl("linearGradient",{id:"leafGrad",x1:"0%",y1:"0%",x2:"100%",y2:"100%"},defs);
  svgEl("stop",{offset:"0%","stop-color":"#4aaf5a"},lg);
  svgEl("stop",{offset:"50%","stop-color":"#3a9a48"},lg);
  svgEl("stop",{offset:"100%","stop-color":"#2a7a35"},lg);
  // Shadow filter
  const flt = svgEl("filter",{id:"leafShadow"},defs);
  svgEl("feDropShadow",{dx:"2",dy:"3",stdDeviation:"3","flood-opacity":"0.2"},flt);

  // Ground plane lines
  const ext=1.6;
  for(let i=-3;i<=3;i++){
    const t=i*0.45; if(Math.abs(t)>ext) continue;
    const hw=Math.sqrt(ext*ext-t*t)*0.6+0.5;
    const p1=p(t,-hw,0), p2=p(t,hw,0);
    svgEl("line",{x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y,stroke:"#2a3040","stroke-width":"0.7","stroke-dasharray":"6,4",opacity:"0.5"},svg);
  }

  // Base ellipse path
  let bePath="";
  for(let j=0;j<=80;j++){
    const phi=(j/80)*TAU, pt=p(Math.cos(phi),Math.sin(phi),0);
    bePath+=(j===0?"M":"L")+pt.x.toFixed(1)+","+pt.y.toFixed(1);
  }
  bePath+="Z";
  svgEl("path",{d:bePath,fill:"none",stroke:"#8090a0","stroke-width":"1.5","stroke-dasharray":"8,5"},svg);

  // Heatmap dots
  const steps=28; const heatPts=[];
  for(let i=0;i<=steps;i++){
    const theta=(i/steps)*(PI/2);
    for(let j=0;j<=steps*2;j++){
      const phi=(j/(steps*2))*TAU;
      const x=Math.sin(theta)*Math.cos(phi), y=Math.sin(theta)*Math.sin(phi), z=Math.cos(theta);
      const pt=p(x,y,z); const val=dd.fn(theta);
      heatPts.push({...pt,val});
    }
  }
  const maxV=Math.max(...heatPts.map(h=>h.val),0.001);
  heatPts.filter((_,i)=>i%3===0).sort((a,b)=>a.z-b.z).forEach(pt=>{
    const inten=pt.val/maxV;
    svgEl("circle",{cx:pt.x,cy:pt.y,r:1.6+inten*2.2,fill:dd.color,opacity:0.06+inten*0.28},svg);
  });

  // Wireframe arcs
  for(let i=0;i<12;i++){
    const phi=(i/12)*TAU; let d="";
    for(let j=0;j<=30;j++){
      const theta=(j/30)*(PI/2);
      const pt=p(Math.sin(theta)*Math.cos(phi),Math.sin(theta)*Math.sin(phi),Math.cos(theta));
      d+=(j===0?"M":"L")+pt.x.toFixed(1)+","+pt.y.toFixed(1);
    }
    svgEl("path",{d,fill:"none",stroke:"#3a4555","stroke-width":"0.5",opacity:"0.35"},svg);
  }
  for(let i=1;i<=5;i++){
    const theta=(i/6)*(PI/2); let d="";
    for(let j=0;j<=60;j++){
      const phi=(j/60)*TAU;
      const pt=p(Math.sin(theta)*Math.cos(phi),Math.sin(theta)*Math.sin(phi),Math.cos(theta));
      d+=(j===0?"M":"L")+pt.x.toFixed(1)+","+pt.y.toFixed(1);
    }
    svgEl("path",{d,fill:"none",stroke:"#3a4555","stroke-width":"0.5",opacity:"0.35"},svg);
  }

  // Hemisphere glow
  svgEl("path",{d:bePath,fill:"url(#hemiGlow)"},svg);

  // Leaf shape
  const leafLen=0.55, leafWid=0.22; let leafD="";
  for(let i=0;i<=40;i++){
    const t=(i/40)*TAU;
    const along=Math.cos(t)*leafLen, across=Math.sin(t)*leafWid*(1-0.3*Math.abs(Math.cos(t)));
    const tx=Math.cos(thetaL)*Math.cos(phiL), ty=Math.cos(thetaL)*Math.sin(phiL), tz=-Math.sin(thetaL);
    const bx=-Math.sin(phiL), by=Math.cos(phiL);
    const lx=along*tx+across*bx, ly=along*ty+across*by, lz=along*tz;
    const pt=p(lx,ly,lz);
    leafD+=(i===0?"M":"L")+pt.x.toFixed(1)+","+pt.y.toFixed(1);
  }
  leafD+="Z";
  svgEl("path",{d:leafD,fill:"url(#leafGrad)",stroke:"#3a8a48","stroke-width":"1.2",filter:"url(#leafShadow)",opacity:"0.92"},svg);
  // Leaf vein
  const tvx=Math.cos(thetaL)*Math.cos(phiL), tvy=Math.cos(thetaL)*Math.sin(phiL), tvz=-Math.sin(thetaL);
  const vl=0.52, vp1=p(-tvx*vl,-tvy*vl,-tvz*vl), vp2=p(tvx*vl,tvy*vl,tvz*vl);
  svgEl("line",{x1:vp1.x,y1:vp1.y,x2:vp2.x,y2:vp2.y,stroke:"#3a8a48","stroke-width":"0.8",opacity:"0.5"},svg);

  // Z-axis
  const zBot=p(0,0,0), zTop=p(0,0,1.5);
  svgEl("line",{x1:zBot.x,y1:zBot.y,x2:zTop.x,y2:zTop.y,stroke:"#c0cad8","stroke-width":"2","stroke-dasharray":"7,5","marker-end":"url(#arrowZ)"},svg);

  // Theta arc
  if(thetaL>0.05){
    let arcD=""; const arcR=0.45;
    for(let i=0;i<=20;i++){
      const a=(i/20)*thetaL;
      const pt=p(Math.sin(a)*Math.cos(phiL)*arcR, Math.sin(a)*Math.sin(phiL)*arcR, Math.cos(a)*arcR);
      arcD+=(i===0?"M":"L")+pt.x.toFixed(1)+","+pt.y.toFixed(1);
    }
    svgEl("path",{d:arcD,fill:"none",stroke:dd.color,"stroke-width":"1.8",opacity:"0.8"},svg);
  }

  // Normal vector
  const nLen=1.15, nOr=p(0,0,0), nTip=p(nlx*nLen,nly*nLen,nlz*nLen);
  svgEl("line",{x1:nOr.x,y1:nOr.y,x2:nTip.x,y2:nTip.y,stroke:dd.color,"stroke-width":"2.8","marker-end":"url(#arrowN)"},svg);

  // Omega_L label (bold vector)
  const omLabel = svgEl("text",{x:nTip.x+8,y:nTip.y-8,fill:dd.color,"font-size":"18","font-weight":"900","font-family":"'EB Garamond', Georgia, serif",stroke:dd.color,"stroke-width":"0.6"},svg);
  omLabel.textContent="\u03A9";
  const omSub = svgEl("tspan",{dy:"4","font-size":"11","font-weight":"400",stroke:"none"},omLabel);
  omSub.textContent="L";

  // Z label
  const zLabel = svgEl("text",{x:zTop.x+6,y:zTop.y-4,fill:"#e0e6ee","font-size":"14","font-weight":"600","font-family":"'EB Garamond', Georgia, serif"},svg);
  zLabel.textContent="z (zenith)";

  // Theta label
  if(thetaL>0.1){
    const mid=p(Math.sin(thetaL/2)*Math.cos(phiL)*0.55, Math.sin(thetaL/2)*Math.sin(phiL)*0.55, Math.cos(thetaL/2)*0.55);
    const tLabel = svgEl("text",{x:mid.x+8,y:mid.y,fill:dd.color,"font-size":"15","font-style":"italic","font-family":"'EB Garamond', Georgia, serif"},svg);
    tLabel.textContent="\u03B8";
    const tSub = svgEl("tspan",{dy:"3","font-size":"10"},tLabel);
    tSub.textContent="L";
  }

  // Density annotation
  const gLabel = svgEl("text",{x:16,y:H-16,fill:"#e0e6ee","font-size":"11","font-family":"'JetBrains Mono', monospace"},svg);
  gLabel.innerHTML = 'ḡ<tspan font-size="8" dy="2">L</tspan><tspan dy="-2">(\u03B8</tspan><tspan font-size="8" dy="2">L</tspan><tspan dy="-2">) = '+gVal.toFixed(3)+'</tspan>';
}

// ── Draw Polar Plot ──
function drawPolar(){
  const svg = document.getElementById("polarSvg");
  clearSvg(svg);
  const W=280, H=340, cx=W/2, cy=150, R=110;

  // Title (inside SVG, at top)
  const title = svgEl("text",{x:W/2,y:10,fill:"#e0e6ee","font-size":"11","font-weight":"700","font-family":"'JetBrains Mono', monospace","text-anchor":"middle","letter-spacing":"0.06em"},svg);
  title.innerHTML = 'POLAR ḡ<tspan font-size="8" dy="2">L</tspan><tspan dy="-2">(\u03B8</tspan><tspan font-size="8" dy="2">L</tspan><tspan dy="-2">) PROFILES</tspan>';

  // Grid circles
  [0.25,0.5,0.75,1.0].forEach(r=>{
    svgEl("circle",{cx,cy,r:R*r,fill:"none",stroke:"#2a3040","stroke-width":"0.6"},svg);
  });

  // Grid lines
  [0,30,60,90].forEach(deg=>{
    const a=deg/180*PI;
    svgEl("line",{x1:cx,y1:cy,x2:cx+Math.sin(a)*R,y2:cy-Math.cos(a)*R,stroke:"#2a3040","stroke-width":"0.6"},svg);
    svgEl("line",{x1:cx,y1:cy,x2:cx-Math.sin(a)*R,y2:cy-Math.cos(a)*R,stroke:"#2a3040","stroke-width":"0.6"},svg);
    // Angle label (right side only, skip 0 and 90 as they have zenith/horizon labels)
    if(deg > 0 && deg < 90){
      const lbl = svgEl("text",{x:cx+Math.sin(a)*(R+14),y:cy-Math.cos(a)*(R+14)+4,fill:"#c0cad8","font-size":"10","text-anchor":"middle","font-family":"'JetBrains Mono', monospace"},svg);
      lbl.textContent = deg+"\u00B0";
    }
  });

  // Distribution curves
  distKeys.forEach(key=>{
    const d=distributions[key], isActive=key===currentDist;
    const maxVal = Math.max(...Array.from({length:50},(_,i)=>d.fn(i/49*PI/2)));
    const normR = R/Math.max(maxVal,0.01);
    let path="";
    for(let i=0;i<=60;i++){
      const theta=(i/60)*(PI/2), val=d.fn(theta), r=val*normR*0.85;
      path+=(i===0?"M":"L")+(cx+Math.sin(theta)*r).toFixed(1)+","+(cy-Math.cos(theta)*r).toFixed(1);
    }
    for(let i=60;i>=0;i--){
      const theta=(i/60)*(PI/2), val=d.fn(theta), r=val*normR*0.85;
      path+="L"+(cx-Math.sin(theta)*r).toFixed(1)+","+(cy-Math.cos(theta)*r).toFixed(1);
    }
    path+="Z";
    svgEl("path",{d:path,fill:isActive?d.color:"none","fill-opacity":isActive?"0.15":"0",stroke:d.color,"stroke-width":isActive?"2.2":"1",opacity:isActive?"1":"0.3"},svg);
  });

  // Angle labels at 0° and 90°
  const zLbl = svgEl("text",{x:cx+4,y:cy-R-10,fill:"#c0cad8","font-size":"10","text-anchor":"start","font-family":"'JetBrains Mono', monospace"},svg);
  zLbl.textContent="0\u00B0";
  const hLbl = svgEl("text",{x:cx+R+6,y:cy-4,fill:"#c0cad8","font-size":"10","text-anchor":"start","font-family":"'JetBrains Mono', monospace"},svg);
  hLbl.textContent="90\u00B0";

  // Internal legend (inside SVG, below the plot)
  const entries = Object.entries(distributions);
  entries.forEach(([key,d],i)=>{
    const col=i%3, row=Math.floor(i/3);
    const lx=16+col*92, ly=278+row*16;
    const isActive=key===currentDist;
    const g = svgEl("g",{opacity:isActive?"1":"0.5"},svg);
    svgEl("line",{x1:lx,y1:ly-3,x2:lx+12,y2:ly-3,stroke:d.color,"stroke-width":isActive?"2.5":"1.5"},g);
    const t = svgEl("text",{x:lx+16,y:ly,fill:"#e0e6ee","font-size":"10","font-family":"'JetBrains Mono', monospace","font-weight":isActive?"600":"400"},g);
    t.textContent=d.label;
  });
}

// ── UI Setup ──
function buildButtons(){
  const container = document.getElementById("distButtons");
  container.innerHTML = "";
  distKeys.forEach(key=>{
    const d=distributions[key];
    const btn = document.createElement("button");
    btn.className = "dist-btn" + (key===currentDist?" active":"");
    btn.textContent = d.label;
    if(key===currentDist){
      btn.style.borderColor = d.color;
      btn.style.background = d.color+"30";
      btn.style.color = d.color;
    }
    btn.onclick = ()=>{ currentDist=key; update(); };
    container.appendChild(btn);
  });
  document.getElementById("distDesc").textContent = distributions[currentDist].desc;
}

function updateSliderColors(){
  const dd = distributions[currentDist];
  document.getElementById("thetaSlider").style.accentColor = dd.color;
  document.getElementById("phiSlider").style.accentColor = dd.color;
  document.getElementById("thetaVal").style.color = dd.color;
  document.getElementById("phiVal").style.color = dd.color;
  document.getElementById("thetaVal").textContent = thetaDeg + "\u00B0";
  document.getElementById("phiVal").textContent = phiDeg + "\u00B0";

  const animBtn = document.getElementById("animateBtn");
  if(animating){
    animBtn.style.background = "#1e1e2a";
    animBtn.style.color = "#c0cad8";
    animBtn.style.border = "1.5px solid #3a3a4a";
    animBtn.innerHTML = "\u23F8 Pause Sweep";
  } else {
    animBtn.style.background = dd.color+"25";
    animBtn.style.color = dd.color;
    animBtn.style.border = "1.5px solid "+dd.color+"60";
    animBtn.innerHTML = "\u25B6 Animate \u03B8 Sweep";
  }
}

function update(){
  buildButtons();
  updateSliderColors();
  drawHemisphere();
  drawPolar();
}

// ── Event listeners ──
document.getElementById("thetaSlider").addEventListener("input", e=>{
  thetaDeg = +e.target.value;
  if(animating){ animating=false; cancelAnimationFrame(animId); }
  update();
});
document.getElementById("phiSlider").addEventListener("input", e=>{
  phiDeg = +e.target.value;
  update();
});
document.getElementById("animateBtn").addEventListener("click", ()=>{
  animating = !animating;
  if(animating){
    let start=null;
    const duration=3000;
    function tick(ts){
      if(!start) start=ts;
      const t=((ts-start)%duration)/duration;
      thetaDeg=Math.round(t*90);
      document.getElementById("thetaSlider").value=thetaDeg;
      update();
      if(animating) animId=requestAnimationFrame(tick);
    }
    animId=requestAnimationFrame(tick);
  } else {
    cancelAnimationFrame(animId);
  }
  updateSliderColors();
});

// ── Init ──
update();
</script>
</body>
</html>
