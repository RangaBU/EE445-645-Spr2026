<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radiant Energy Flow Across a Surface</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #64b5f6;
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 0 0 20px rgba(100, 181, 246, 0.5);
        }
        
        .subtitle {
            text-align: center;
            color: #ffb74d;
            margin-bottom: 20px;
            font-size: 1.2em;
            font-style: italic;
        }
        
        .equation-box {
            background: rgba(30, 30, 50, 0.8);
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #64b5f6;
            box-shadow: 0 0 20px rgba(100, 181, 246, 0.3);
        }
        
        .equation-box h2 {
            color: #64b5f6;
            margin-top: 0;
            text-align: center;
        }
        
        .equation {
            font-size: 1.3em;
            text-align: center;
            color: #ffeb3b;
            font-family: 'Courier New', monospace;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin: 10px 0;
        }
        
        canvas {
            display: block;
            margin: 20px auto;
            background: #000000;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(100, 181, 246, 0.3);
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        label {
            display: inline-block;
            width: 180px;
            color: #b0b0b0;
            font-size: 0.95em;
        }
        
        input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        
        .value-display {
            display: inline-block;
            width: 80px;
            text-align: right;
            color: #64b5f6;
            font-weight: bold;
        }
        
        .legend {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }
        
        .legend h3 {
            color: #64b5f6;
            margin-top: 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
        }
        
        .legend-color {
            width: 40px;
            height: 25px;
            margin-right: 15px;
            border-radius: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: scale(1.05);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .button-group {
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Radiant Energy Flow Across a Surface</h1>
        <div class="subtitle">Visible Light Photons (400-700 nm)</div>
        
        <div class="equation-box">
            <h2>Energy Flow Equation</h2>
            <div class="equation">
                dE = dn (hν) = f(r⃗,ν,Ω̂,t) dν dΩ ds |n⃗·Ω̂| c dt (hν)
            </div>
            <p style="text-align: center; color: #b0b0b0; margin-top: 15px;">
                Energy crossing surface ds in time dt, within solid angle dΩ, frequency range dν
            </p>
        </div>
        
        <canvas id="canvas" width="1200" height="800"></canvas>
        
        <div class="button-group">
            <button onclick="resetView()">Reset View</button>
            <button onclick="toggleAnimation()">Pause/Resume</button>
        </div>
        
        <div class="controls">
            <h3 style="color: #64b5f6; margin-top: 0;">Flow Parameters</h3>
            <div class="control-row">
                <div>
                    <div class="control-group">
                        <label>Surface Tilt Angle:</label>
                        <input type="range" id="surfaceAngle" min="0" max="75" value="30" step="5">
                        <span class="value-display" id="angleValue">30°</span>
                    </div>
                    <div class="control-group">
                        <label>Flow Direction:</label>
                        <input type="range" id="flowDirection" min="-30" max="30" value="-30" step="5">
                        <span class="value-display" id="flowValue">-30°</span>
                    </div>
                    <div class="control-group">
                        <label>Solid Angle (dΩ):</label>
                        <input type="range" id="solidAngle" min="15" max="45" value="25" step="5">
                        <span class="value-display" id="solidValue">25°</span>
                    </div>
                </div>
                <div>
                    <div class="control-group">
                        <label>Photon Flux:</label>
                        <input type="range" id="photonFlux" min="1" max="15" value="3" step="1">
                        <span class="value-display" id="fluxValue">3</span>
                    </div>
                    <div class="control-group">
                        <label>Surface Size (ds):</label>
                        <input type="range" id="surfaceSize" min="80" max="160" value="120" step="10">
                        <span class="value-display" id="sizeValue">120</span>
                    </div>
                    <div class="control-group">
                        <label>View Rotation:</label>
                        <input type="range" id="viewRotation" min="-45" max="45" value="15" step="5">
                        <span class="value-display" id="rotValue">15°</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <h3>Component Legend</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(100, 181, 246, 0.4); border-color: #64b5f6;"></div>
                <span><strong>ds (blue rectangle)</strong> - Surface area element</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(76, 175, 80, 0.5); border-color: #4caf50;"></div>
                <span><strong>ds |n⃗·Ω̂| (green rectangle)</strong> - Projected surface area (perpendicular to Ω̂)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 64, 129, 0.8); border-color: #ff4081;"></div>
                <span><strong>n⃗ (pink arrow)</strong> - Surface normal vector</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 235, 59, 0.8); border-color: #ffeb3b;"></div>
                <span><strong>Ω̂ (yellow arrow)</strong> - Direction of energy flow</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(to right, #8b00ff, #4169e1, #00bfff, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);"></div>
                <span><strong>Photons</strong> - Visible light (400-700 nm), color indicates wavelength</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(255, 255, 255, 0.2); border-color: white;"></div>
                <span><strong>Energy vs Time Plot</strong> - Shows dE crossing the surface</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let photons = [];
        let isAnimating = true;
        let time = 0;
        let energyData = [];
        const maxDataPoints = 100;
        
        // Physical constants
        const c = 3e8; // speed of light (m/s)
        const h = 6.626e-34; // Planck constant (J·s)
        
        class Photon {
            constructor(startX, startY, flowAngle, spreadAngle) {
                // Random wavelength in visible spectrum (400-700 nm)
                this.wavelength = 400 + Math.random() * 300; // nm
                this.frequency = c / (this.wavelength * 1e-9); // Hz
                this.energy = h * this.frequency; // Joules
                
                // Position
                const angleVariation = (Math.random() - 0.5) * spreadAngle;
                this.angle = flowAngle + angleVariation;
                
                // Starting position with spread
                const lateralSpread = 100;
                const perpAngle = flowAngle + Math.PI / 2;
                const offset = (Math.random() - 0.5) * lateralSpread;
                
                this.x = startX + offset * Math.cos(perpAngle) - 300 * Math.cos(flowAngle);
                this.y = startY + offset * Math.sin(perpAngle) - 300 * Math.sin(flowAngle);
                
                this.speed = 4;
                this.size = 3.5;
                this.active = true;
                this.crossedSurface = false;
            }
            
            getColor() {
                // Map wavelength to RGB color
                const wl = this.wavelength;
                let r, g, b;
                
                if (wl >= 400 && wl < 440) {
                    r = -(wl - 440) / (440 - 400);
                    g = 0;
                    b = 1;
                } else if (wl >= 440 && wl < 490) {
                    r = 0;
                    g = (wl - 440) / (490 - 440);
                    b = 1;
                } else if (wl >= 490 && wl < 510) {
                    r = 0;
                    g = 1;
                    b = -(wl - 510) / (510 - 490);
                } else if (wl >= 510 && wl < 580) {
                    r = (wl - 510) / (580 - 510);
                    g = 1;
                    b = 0;
                } else if (wl >= 580 && wl < 645) {
                    r = 1;
                    g = -(wl - 645) / (645 - 580);
                    b = 0;
                } else if (wl >= 645 && wl <= 700) {
                    r = 1;
                    g = 0;
                    b = 0;
                } else {
                    r = g = b = 0;
                }
                
                // Intensity factor
                let factor;
                if (wl >= 400 && wl < 420) {
                    factor = 0.3 + 0.7 * (wl - 400) / (420 - 400);
                } else if (wl >= 420 && wl < 700) {
                    factor = 1;
                } else if (wl >= 700 && wl <= 750) {
                    factor = 0.3 + 0.7 * (750 - wl) / (750 - 700);
                } else {
                    factor = 0.3;
                }
                
                r = Math.round(r * factor * 255);
                g = Math.round(g * factor * 255);
                b = Math.round(b * factor * 255);
                
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // Check if out of bounds
                if (this.x > canvas.width + 50 || this.y > canvas.height + 50 || 
                    this.x < -50 || this.y < -50) {
                    this.active = false;
                }
            }
            
            draw(ctx) {
                const color = this.getColor();
                
                // Bright core
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                
                // Glow
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.4, color.replace('rgb', 'rgba').replace(')', ', 0.4)'));
                gradient.addColorStop(1, color.replace('rgb', 'rgba').replace(')', ', 0)'));
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            checkSurfaceCrossing(surfaceData) {
                if (this.crossedSurface) return false;
                
                // Check if photon crossed the projected surface
                const { centerX, centerY, projWidth, projHeight, flowAngle } = surfaceData;
                
                // Transform photon position to surface-aligned coordinates
                const dx = this.x - centerX;
                const dy = this.y - centerY;
                
                const perpAngle = flowAngle + Math.PI / 2;
                const alongSurface = dx * Math.cos(perpAngle) + dy * Math.sin(perpAngle);
                const acrossSurface = dx * Math.cos(flowAngle) + dy * Math.sin(flowAngle);
                
                // Check if within projected surface bounds and has crossed
                if (Math.abs(alongSurface) < projWidth / 2 && 
                    Math.abs(acrossSurface) < projHeight / 2 &&
                    acrossSurface > 0 && acrossSurface < 20) {
                    this.crossedSurface = true;
                    return true;
                }
                return false;
            }
        }
        
        function draw3DSurface(centerX, centerY, size, tiltAngle, viewRotation) {
            const tilt = tiltAngle * Math.PI / 180;
            const view = viewRotation * Math.PI / 180;
            
            // Surface corners in 3D
            const halfSize = size / 2;
            const depth = 30;
            
            // Define 3D vertices
            const vertices3D = [
                [-halfSize, -depth/2, 0],
                [halfSize, -depth/2, 0],
                [halfSize, depth/2, 0],
                [-halfSize, depth/2, 0]
            ];
            
            // Apply tilt and view rotation, then project to 2D
            const vertices2D = vertices3D.map(([x, y, z]) => {
                // Tilt around x-axis
                let y1 = y * Math.cos(tilt) - z * Math.sin(tilt);
                let z1 = y * Math.sin(tilt) + z * Math.cos(tilt);
                
                // Rotate around y-axis for view
                let x2 = x * Math.cos(view) + z1 * Math.sin(view);
                let z2 = -x * Math.sin(view) + z1 * Math.cos(view);
                
                // Perspective projection
                const perspective = 500;
                const scale = perspective / (perspective + z2);
                
                return {
                    x: centerX + x2 * scale,
                    y: centerY + y1 * scale,
                    z: z2
                };
            });
            
            // Draw surface with shading
            ctx.beginPath();
            ctx.moveTo(vertices2D[0].x, vertices2D[0].y);
            vertices2D.forEach(v => ctx.lineTo(v.x, v.y));
            ctx.closePath();
            
            // Gradient based on tilt
            const gradient = ctx.createLinearGradient(
                vertices2D[0].x, vertices2D[0].y,
                vertices2D[2].x, vertices2D[2].y
            );
            gradient.addColorStop(0, 'rgba(100, 181, 246, 0.3)');
            gradient.addColorStop(1, 'rgba(100, 181, 246, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Border
            ctx.strokeStyle = '#64b5f6';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#64b5f6';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('ds', vertices2D[1].x + 10, vertices2D[1].y - 10);
            
            return { vertices2D, tilt, view };
        }
        
        function drawProjectedSurface(centerX, centerY, size, flowAngle, viewRotation, cosTheta) {
            const projectedSize = size * cosTheta;
            const perpAngle = flowAngle + Math.PI / 2;
            const view = viewRotation * Math.PI / 180;
            
            const halfSize = projectedSize / 2;
            const depth = 30;
            
            // 3D vertices for projected surface (perpendicular to flow)
            const vertices3D = [
                [-halfSize, -depth/2, 0],
                [halfSize, -depth/2, 0],
                [halfSize, depth/2, 0],
                [-halfSize, depth/2, 0]
            ];
            
            // Rotate to be perpendicular to flow direction
            const vertices2D = vertices3D.map(([x, y, z]) => {
                // Rotate to flow direction
                let x1 = x * Math.cos(perpAngle) - y * Math.sin(perpAngle);
                let y1 = x * Math.sin(perpAngle) + y * Math.cos(perpAngle);
                
                // View rotation
                let x2 = x1 * Math.cos(view) + z * Math.sin(view);
                let z2 = -x1 * Math.sin(view) + z * Math.cos(view);
                
                // Perspective
                const perspective = 500;
                const scale = perspective / (perspective + z2);
                
                return {
                    x: centerX + x2 * scale,
                    y: centerY + y1 * scale,
                    z: z2
                };
            });
            
            // Draw projected surface
            ctx.beginPath();
            ctx.moveTo(vertices2D[0].x, vertices2D[0].y);
            vertices2D.forEach(v => ctx.lineTo(v.x, v.y));
            ctx.closePath();
            
            const gradient = ctx.createLinearGradient(
                vertices2D[0].x, vertices2D[0].y,
                vertices2D[2].x, vertices2D[2].y
            );
            gradient.addColorStop(0, 'rgba(76, 175, 80, 0.3)');
            gradient.addColorStop(1, 'rgba(76, 175, 80, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#4caf50';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('ds|n⃗·Ω̂|', vertices2D[2].x + 10, vertices2D[2].y + 5);
            
            // Draw projection lines
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.4)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(vertices2D[i].x, vertices2D[i].y);
                // Connect to surface (this is simplified)
                ctx.lineTo(centerX + (i < 2 ? -halfSize : halfSize) * Math.cos(view),
                          centerY + (i % 3 === 0 ? -depth/2 : depth/2));
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            return {
                centerX,
                centerY,
                projWidth: projectedSize,
                projHeight: depth,
                flowAngle
            };
        }
        
        function drawVectors(centerX, centerY, flowAngle, tilt, viewRotation) {
            // Normal vector
            const normalAngle = tilt - Math.PI / 2;
            const normalLen = 90;
            const nx = centerX + normalLen * Math.cos(normalAngle);
            const ny = centerY + normalLen * Math.sin(normalAngle);
            
            ctx.strokeStyle = '#ff4081';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(nx, ny);
            ctx.stroke();
            
            // Arrowhead
            drawArrowhead(nx, ny, normalAngle, 12, '#ff4081');
            
            ctx.fillStyle = '#ff4081';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('n⃗', nx + 10, ny - 10);
            
            // Flow direction
            const flowLen = 110;
            const fx = centerX + flowLen * Math.cos(flowAngle);
            const fy = centerY + flowLen * Math.sin(flowAngle);
            
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 5;
            ctx.shadowColor = 'rgba(255, 235, 59, 0.5)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(fx, fy);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            drawArrowhead(fx, fy, flowAngle, 15, '#ffeb3b');
            
            ctx.fillStyle = '#ffeb3b';
            ctx.font = 'bold 22px Arial';
            ctx.shadowColor = 'rgba(255, 235, 59, 0.5)';
            ctx.shadowBlur = 10;
            ctx.fillText('Ω̂', fx + 10, fy - 10);
            ctx.shadowBlur = 0;
            
            // Angle arc
            const theta = Math.abs(normalAngle - flowAngle);
            const arcRadius = 50;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const startAngle = Math.min(normalAngle, flowAngle);
            const endAngle = Math.max(normalAngle, flowAngle);
            ctx.arc(centerX, centerY, arcRadius, startAngle, endAngle);
            ctx.stroke();
            
            const midAngle = (normalAngle + flowAngle) / 2;
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px Arial';
            ctx.fillText('θ', centerX + (arcRadius + 15) * Math.cos(midAngle),
                        centerY + (arcRadius + 15) * Math.sin(midAngle));
            
            return theta;
        }
        
        function drawArrowhead(x, y, angle, size, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - size * Math.cos(angle - 0.4), y - size * Math.sin(angle - 0.4));
            ctx.moveTo(x, y);
            ctx.lineTo(x - size * Math.cos(angle + 0.4), y - size * Math.sin(angle + 0.4));
            ctx.stroke();
        }
        
        function drawSolidAngleCone(centerX, centerY, flowAngle, coneAngle) {
            const length = 250;
            const halfCone = coneAngle / 2;
            
            const angle1 = flowAngle - halfCone;
            const angle2 = flowAngle + halfCone;
            
            // Fill
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + length * Math.cos(angle1), centerY + length * Math.sin(angle1));
            ctx.arc(centerX, centerY, length, angle1, angle2);
            ctx.lineTo(centerX, centerY);
            ctx.fillStyle = 'rgba(255, 152, 0, 0.1)';
            ctx.fill();
            
            // Edges
            ctx.strokeStyle = 'rgba(255, 152, 0, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + length * Math.cos(angle1), centerY + length * Math.sin(angle1));
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + length * Math.cos(angle2), centerY + length * Math.sin(angle2));
            ctx.stroke();
            
            ctx.fillStyle = '#ff9800';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('dΩ', centerX + length * 0.5 * Math.cos(flowAngle),
                        centerY + length * 0.5 * Math.sin(flowAngle) - 25);
        }
        
        function drawEnergyPlot() {
            const plotX = canvas.width - 280;
            const plotY = 30;
            const plotWidth = 250;
            const plotHeight = 150;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(plotX, plotY, plotWidth, plotHeight);
            ctx.strokeStyle = 'rgba(100, 181, 246, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(plotX, plotY, plotWidth, plotHeight);
            
            // Title
            ctx.fillStyle = '#64b5f6';
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Energy dE vs Time', plotX + 60, plotY + 20);
            
            // Grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                const y = plotY + (i * plotHeight / 4);
                ctx.beginPath();
                ctx.moveTo(plotX + 10, y);
                ctx.lineTo(plotX + plotWidth - 10, y);
                ctx.stroke();
            }
            
            // Plot data
            if (energyData.length > 1) {
                const maxEnergy = Math.max(...energyData.map(d => d.energy), 0.1);
                
                // Fill area under curve
                ctx.fillStyle = 'rgba(255, 235, 59, 0.2)';
                ctx.beginPath();
                ctx.moveTo(plotX + 10, plotY + plotHeight - 20);
                
                energyData.forEach((point, i) => {
                    const x = plotX + 10 + (i / maxDataPoints) * (plotWidth - 20);
                    const y = plotY + plotHeight - 20 - (point.energy / maxEnergy) * (plotHeight - 40);
                    ctx.lineTo(x, y);
                });
                
                ctx.lineTo(plotX + 10 + ((energyData.length - 1) / maxDataPoints) * (plotWidth - 20), 
                          plotY + plotHeight - 20);
                ctx.closePath();
                ctx.fill();
                
                // Draw line
                ctx.strokeStyle = '#ffeb3b';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                energyData.forEach((point, i) => {
                    const x = plotX + 10 + (i / maxDataPoints) * (plotWidth - 20);
                    const y = plotY + plotHeight - 20 - (point.energy / maxEnergy) * (plotHeight - 40);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#ffeb3b';
                energyData.forEach((point, i) => {
                    if (i % 3 === 0) {  // Only draw every 3rd point
                        const x = plotX + 10 + (i / maxDataPoints) * (plotWidth - 20);
                        const y = plotY + plotHeight - 20 - (point.energy / maxEnergy) * (plotHeight - 40);
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Current value
                const current = energyData[energyData.length - 1].energy;
                ctx.fillStyle = '#ffeb3b';
                ctx.font = 'bold 12px Arial';
                ctx.fillText(`${current.toFixed(1)} photons/frame`, plotX + 10, plotY + plotHeight - 5);
                
                // Max value
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '10px Arial';
                ctx.fillText(`Max: ${maxEnergy.toFixed(1)}`, plotX + plotWidth - 60, plotY + 35);
            } else {
                // No data yet
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '12px Arial';
                ctx.fillText('Accumulating data...', plotX + 70, plotY + plotHeight / 2);
            }
            
            // Axes labels
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '11px Arial';
            ctx.fillText('Time →', plotX + plotWidth - 50, plotY + plotHeight - 5);
            ctx.save();
            ctx.translate(plotX + 15, plotY + 80);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Photons', 0, 0);
            ctx.restore();
        }
        
        function spawnPhotons(flowAngle, coneAngle, flux) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let i = 0; i < flux; i++) {
                photons.push(new Photon(centerX, centerY, flowAngle, coneAngle));
            }
        }
        
        function animate() {
            if (!isAnimating) {
                requestAnimationFrame(animate);
                return;
            }
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const surfaceSize = parseFloat(document.getElementById('surfaceSize').value);
            const surfaceTilt = parseFloat(document.getElementById('surfaceAngle').value);
            const flowDir = parseFloat(document.getElementById('flowDirection').value);
            const solidAngle = parseFloat(document.getElementById('solidAngle').value) * Math.PI / 180;
            const flux = parseInt(document.getElementById('photonFlux').value);
            const viewRot = parseFloat(document.getElementById('viewRotation').value);
            
            const tiltRad = surfaceTilt * Math.PI / 180;
            const flowAngle = tiltRad + flowDir * Math.PI / 180;
            
            // Calculate cos(theta)
            const normalAngle = tiltRad - Math.PI / 2;
            const theta = Math.abs(normalAngle - flowAngle);
            const cosTheta = Math.cos(theta);
            
            // Draw solid angle cone
            drawSolidAngleCone(centerX, centerY, flowAngle, solidAngle);
            
            // Draw surfaces
            const surfaceData = draw3DSurface(centerX, centerY, surfaceSize, surfaceTilt, viewRot);
            const projData = drawProjectedSurface(centerX, centerY, surfaceSize, flowAngle, viewRot, cosTheta);
            
            // Draw vectors
            drawVectors(centerX, centerY, flowAngle, tiltRad, viewRot);
            
            // Spawn new photons
            if (time % 5 === 0) {
                spawnPhotons(flowAngle, solidAngle, flux);
            }
            
            // Update and draw photons, count crossings
            let crossingCount = 0;
            photons = photons.filter(p => {
                if (!p.active) return false;
                p.update();
                if (p.checkSurfaceCrossing(projData)) {
                    crossingCount++;
                }
                p.draw(ctx);
                return true;
            });
            
            // Update energy data
            energyData.push({ time: time, energy: crossingCount });
            if (energyData.length > maxDataPoints) {
                energyData.shift();
            }
            
            // Draw energy plot
            drawEnergyPlot();
            
            // Display info
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`θ = ${Math.round(theta * 180 / Math.PI)}°`, 20, 30);
            ctx.fillText(`cos(θ) = ${cosTheta.toFixed(3)}`, 20, 55);
            ctx.fillText(`Projected area = ${(surfaceSize * cosTheta).toFixed(1)} (${(cosTheta * 100).toFixed(0)}% of ds)`, 20, 80);
            ctx.fillText(`Active photons: ${photons.length}`, 20, 105);
            ctx.fillText(`Crossing surface: ${crossingCount} photons/frame`, 20, 130);
            
            time++;
            requestAnimationFrame(animate);
        }
        
        function resetView() {
            document.getElementById('surfaceAngle').value = 30;
            document.getElementById('flowDirection').value = -30;
            document.getElementById('solidAngle').value = 25;
            document.getElementById('surfaceSize').value = 120;
            document.getElementById('photonFlux').value = 3;
            document.getElementById('viewRotation').value = 15;
            
            document.getElementById('angleValue').textContent = '30°';
            document.getElementById('flowValue').textContent = '-30°';
            document.getElementById('solidValue').textContent = '25°';
            document.getElementById('sizeValue').textContent = '120';
            document.getElementById('fluxValue').textContent = '3';
            document.getElementById('rotValue').textContent = '15°';
            
            photons = [];
            energyData = [];
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
        }
        
        // Event listeners
        ['surfaceAngle', 'flowDirection', 'solidAngle', 'surfaceSize', 'photonFlux', 'viewRotation'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                let valueId = id.replace('surfaceAngle', 'angle')
                              .replace('flowDirection', 'flow')
                              .replace('solidAngle', 'solid')
                              .replace('surfaceSize', 'size')
                              .replace('photonFlux', 'flux')
                              .replace('viewRotation', 'rot') + 'Value';
                
                const suffix = (id.includes('Angle') || id.includes('Direction') || id.includes('Rotation')) ? '°' : '';
                document.getElementById(valueId).textContent = e.target.value + suffix;
            });
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>