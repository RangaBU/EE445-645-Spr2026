<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photon Inscattering - 3D Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 220px;
            font-size: 12px;
        }
        h2 {
            margin: 0 0 10px 0;
            color: #1a1a2e;
            font-size: 16px;
            border-bottom: 2px solid #0f3460;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0 3px 0;
            color: #333;
            font-weight: 600;
            font-size: 12px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin: 6px 0;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #16213e;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        input[type="checkbox"] {
            margin-right: 6px;
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            font-size: 11px;
            max-width: 280px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 30px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 320px;
            font-size: 11px;
            line-height: 1.6;
        }
        .equation {
            background: #f0f0f0;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            line-height: 1.5;
        }
        .vector {
            font-weight: bold;
            position: relative;
            display: inline-block;
        }
        .vector.omega::after {
            content: '→';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
        }
        .section-label {
            font-weight: bold;
            color: #0f3460;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>Controls</h2>
        <div class="checkbox-container">
            <input type="checkbox" id="showVolume" checked>
            <label for="showVolume">Show Volume Element</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showPath" checked>
            <label for="showPath">Show Path Δξ</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showPhotons" checked>
            <label for="showPhotons">Show Static Photons</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showIncoming" checked>
            <label for="showIncoming">Show Incoming Ω'</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showHost" checked>
            <label for="showHost">Show Host Material</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showLabels" checked>
            <label for="showLabels">Show Labels</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="enableAnimation">
            <label for="enableAnimation">Enable Animation</label>
        </div>
        <button id="resetView">Reset View</button>
    </div>

    <div id="info">
        <h2 style="font-size: 14px; margin-top: 0;">Inscattering Process</h2>
        
        <div class="section-label">Volume Element:</div>
        <div class="equation">
            Δr = ΔS Δξ at point <span class="vector">r</span>
        </div>
        
        <div class="section-label">Target Photons:</div>
        <p style="margin: 4px 0; color: #333;">
            • Frequency: (ν, ν+Δν)<br>
            • Direction: <span class="vector omega">Ω</span><br>
            • Solid angle: Δ<span class="vector omega">Ω</span>
        </p>
        
        <div class="section-label">Inscattered Gain:</div>
        <div class="equation">
ΔS Δξ Δν Δ<span class="vector omega">Ω</span> c Δt
∫∫ σ<sub>s</sub>(<span class="vector omega">Ω</span>'→<span class="vector omega">Ω</span>,ν'→ν) f(<span class="vector">r</span>,ν',<span class="vector omega">Ω</span>',t) dν' d<span class="vector omega">Ω</span>'
        </div>
        
        <p style="margin: 6px 0; color: #333; font-size: 10px;">
            Photons from all (<span class="vector omega">Ω</span>',ν') scatter into (<span class="vector omega">Ω</span>,ν)
        </p>
    </div>

    <div id="legend">
        <h2 style="font-size: 14px; margin-top: 0;">Legend</h2>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(100, 149, 237, 0.4); border: 2px solid #6495ED;"></div>
            <span>Volume ΔS·Δξ at point <span class="vector">r</span></span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFFFFF; border: 1px solid #999;"></div>
            <span>Host Material</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFD700;"></div>
            <span>Path length Δξ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(to right, #FF00FF, #00FFFF, #FFFF00);"></div>
            <span>Incoming <span class="vector omega">Ω</span>' (various)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00FF00;"></div>
            <span>Target <span class="vector omega">Ω</span> (green, gained)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: linear-gradient(to right, #FFFF00, #00FF00);"></div>
            <span>Flash (inscattering event)</span>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x6495ED, 0.5);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        function createTextLabel(text, position, color = '#FFFFFF', fontSize = 40) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.roundRect(10, 10, canvas.width - 20, canvas.height - 20, 10);
            context.fill();
            
            if (text.includes('⃗')) {
                const baseText = text.replace('⃗', '');
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(baseText, canvas.width / 2, canvas.height / 2 + 5);
                
                const textWidth = context.measureText(baseText).width;
                const arrowX = canvas.width / 2;
                const arrowY = canvas.height / 2 - fontSize * 0.45;
                const arrowWidth = textWidth * 0.9;
                const arrowHeight = fontSize * 0.15;
                
                context.beginPath();
                context.moveTo(arrowX - arrowWidth/2, arrowY);
                context.lineTo(arrowX + arrowWidth/2, arrowY);
                context.strokeStyle = color;
                context.lineWidth = 3;
                context.stroke();
                
                context.beginPath();
                context.moveTo(arrowX + arrowWidth/2, arrowY);
                context.lineTo(arrowX + arrowWidth/2 - arrowHeight, arrowY - arrowHeight/2);
                context.lineTo(arrowX + arrowWidth/2 - arrowHeight, arrowY + arrowHeight/2);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            } else {
                context.font = `bold ${fontSize}px Arial`;
                context.fillStyle = color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 0.5, 1);
            sprite.position.copy(position);
            
            return sprite;
        }

        function createArrow(origin, direction, length, color, linewidth = 3) {
            const arrow = new THREE.ArrowHelper(
                direction.normalize(),
                origin,
                length,
                color,
                0.3,
                0.2
            );
            arrow.line.material.linewidth = linewidth;
            return arrow;
        }

        function createParticleWithSphere(origin, direction, length, color, sphereRadius = 0.12) {
            const group = new THREE.Group();
            
            const arrow = new THREE.ArrowHelper(
                direction.normalize(),
                origin,
                length,
                color,
                0.3,
                0.2
            );
            arrow.line.material.linewidth = 2;
            group.add(arrow);
            
            const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.4
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            const tipPosition = origin.clone().add(direction.clone().normalize().multiplyScalar(length));
            sphere.position.copy(tipPosition);
            group.add(sphere);
            
            return group;
        }

        const omegaDirection = new THREE.Vector3(1, 0, 0).normalize();
        const deltaS = 1.5;
        const deltaXi = 3.5;

        const crossSectionGeometry = new THREE.PlaneGeometry(deltaS, deltaS);
        const crossSectionMaterial = new THREE.MeshPhongMaterial({
            color: 0x6495ED,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), omegaDirection);
        
        const crossSection = new THREE.Mesh(crossSectionGeometry, crossSectionMaterial);
        crossSection.applyQuaternion(quaternion);
        crossSection.position.set(-2, 0, 0);
        scene.add(crossSection);

        const crossSectionEdges = new THREE.LineSegments(
            new THREE.EdgesGeometry(crossSectionGeometry),
            new THREE.LineBasicMaterial({ color: 0x6495ED, linewidth: 2 })
        );
        crossSectionEdges.applyQuaternion(quaternion);
        crossSectionEdges.position.copy(crossSection.position);
        scene.add(crossSectionEdges);

        const crossSectionLabel = createTextLabel('ΔS (in)', new THREE.Vector3(-2, deltaS/2 + 0.5, 0), '#6495ED', 40);
        scene.add(crossSectionLabel);

        const crossSectionOut = new THREE.Mesh(crossSectionGeometry, crossSectionMaterial);
        crossSectionOut.applyQuaternion(quaternion);
        crossSectionOut.position.set(1.5, 0, 0);
        scene.add(crossSectionOut);

        const crossSectionOutEdges = new THREE.LineSegments(
            new THREE.EdgesGeometry(crossSectionGeometry),
            new THREE.LineBasicMaterial({ color: 0x6495ED, linewidth: 2 })
        );
        crossSectionOutEdges.applyQuaternion(quaternion);
        crossSectionOutEdges.position.copy(crossSectionOut.position);
        scene.add(crossSectionOutEdges);

        const crossSectionOutLabel = createTextLabel('ΔS (out)', new THREE.Vector3(1.5, deltaS/2 + 0.5, 0), '#6495ED', 40);
        scene.add(crossSectionOutLabel);

        const pathStartPos = crossSection.position.clone();
        const pathEndPos = pathStartPos.clone().add(omegaDirection.clone().multiplyScalar(deltaXi));
        
        const markerOffset = new THREE.Vector3(0, -1.2, 0);
        const markerStart = pathStartPos.clone().add(markerOffset);
        const markerEnd = pathEndPos.clone().add(markerOffset);
        
        const lineGeometry = new THREE.BufferGeometry().setFromPoints([markerStart, markerEnd]);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xFFD700, linewidth: 3 });
        const markerLine = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(markerLine);
        
        const tickHeight = 0.2;
        const startTickTop = markerStart.clone().add(new THREE.Vector3(0, tickHeight, 0));
        const startTickBottom = markerStart.clone().add(new THREE.Vector3(0, -tickHeight, 0));
        const startTickGeometry = new THREE.BufferGeometry().setFromPoints([startTickTop, startTickBottom]);
        const startTick = new THREE.Line(startTickGeometry, lineMaterial);
        scene.add(startTick);
        
        const endTickTop = markerEnd.clone().add(new THREE.Vector3(0, tickHeight, 0));
        const endTickBottom = markerEnd.clone().add(new THREE.Vector3(0, -tickHeight, 0));
        const endTickGeometry = new THREE.BufferGeometry().setFromPoints([endTickTop, endTickBottom]);
        const endTick = new THREE.Line(endTickGeometry, lineMaterial);
        scene.add(endTick);

        const markerMidpoint = markerStart.clone().add(markerEnd).multiplyScalar(0.5);
        const pathLabel = createTextLabel('Δξ', markerMidpoint.clone().add(new THREE.Vector3(0, -0.5, 0)), '#FFD700', 45);
        scene.add(pathLabel);

        const cylQuaternion = new THREE.Quaternion();
        cylQuaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), omegaDirection);
        
        const volumeGeometry = new THREE.CylinderGeometry(deltaS/2, deltaS/2, deltaXi, 32, 1, true);
        const volumeMaterial = new THREE.MeshPhongMaterial({
            color: 0x6495ED,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
        });
        const volumeElement = new THREE.Mesh(volumeGeometry, volumeMaterial);
        volumeElement.applyQuaternion(cylQuaternion);
        
        const volumeCenter = pathStartPos.clone().add(omegaDirection.clone().multiplyScalar(deltaXi/2));
        volumeElement.position.copy(volumeCenter);
        scene.add(volumeElement);

        const hostMaterialSpheres = [];
        const hostSphereRadius = 0.06;
        const numHostSpheres = 60;
        
        for (let i = 0; i < numHostSpheres; i++) {
            const sphereGeometry = new THREE.SphereGeometry(hostSphereRadius, 12, 12);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0xCCCCCC,
                emissiveIntensity: 0.2,
                shininess: 30
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * (deltaS/2 - hostSphereRadius);
            const alongPath = Math.random() * deltaXi;
            
            const localPos = new THREE.Vector3(
                radius * Math.cos(angle),
                0,
                radius * Math.sin(angle)
            );
            localPos.applyQuaternion(cylQuaternion);
            
            sphere.position.copy(pathStartPos.clone()
                .add(omegaDirection.clone().multiplyScalar(alongPath))
                .add(localPos));
            
            hostMaterialSpheres.push(sphere);
            scene.add(sphere);
        }

        const volumeLabel = createTextLabel('Δr = ΔS·Δξ', volumeCenter.clone().add(new THREE.Vector3(0, 1.2, 0)), '#6495ED', 40);
        scene.add(volumeLabel);

        const pointRLabel = createTextLabel('r⃗', volumeCenter.clone().add(new THREE.Vector3(0.3, -0.8, 0)), '#FFFFFF', 40);
        scene.add(pointRLabel);

        // Static incoming photons from various directions (Ω')
        const incomingPhotons = [];
        const incomingLabels = [];
        const incomingColors = [0xFF00FF, 0x00FFFF, 0xFFFF00, 0xFF8800, 0xFF0088, 0x88FF00];
        
        for (let i = 0; i < 10; i++) {
            const theta = Math.random() * Math.PI;
            const phi = Math.random() * 2 * Math.PI;
            const incomingDir = new THREE.Vector3(
                Math.sin(theta) * Math.cos(phi),
                Math.sin(theta) * Math.sin(phi),
                Math.cos(theta)
            ).normalize();
            
            const startDist = 2.0 + Math.random() * 1.0;
            const startPos = volumeCenter.clone().add(incomingDir.clone().multiplyScalar(-startDist));
            
            const color = incomingColors[i % incomingColors.length];
            const photon = createParticleWithSphere(startPos, incomingDir, 1.5, color, 0.09);
            incomingPhotons.push(photon);
            scene.add(photon);
            
            if (i === 0) {
                const labelPos = startPos.clone().add(new THREE.Vector3(0, 0.5, 0));
                const label = createTextLabel("Incoming Ω'", labelPos, '#FF00FF', 35);
                incomingLabels.push(label);
                scene.add(label);
            }
        }

        // Static target direction photons (green, along Ω)
        const targetPhotons = [];
        const targetLabels = [];
        
        for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * 2 * Math.PI;
            const radius = (deltaS/2) * 0.5;
            
            const offset = new THREE.Vector3(
                radius * Math.cos(angle),
                0,
                radius * Math.sin(angle)
            );
            offset.applyQuaternion(cylQuaternion);
            
            const startPos = pathEndPos.clone().add(offset);
            const photon = createParticleWithSphere(startPos, omegaDirection, 1.0, 0x00FF00, 0.10);
            targetPhotons.push(photon);
            scene.add(photon);
            
            if (i === 0) {
                const labelPos = startPos.clone().add(new THREE.Vector3(1.2, 0.5, 0));
                const label = createTextLabel('Target', labelPos, '#00FF00', 35);
                targetLabels.push(label);
                scene.add(label);
            }
        }

        const omegaLabel = createTextLabel('Ω⃗', pathEndPos.clone().add(new THREE.Vector3(0.5, -0.6, 0)), '#FFD700', 50);
        scene.add(omegaLabel);

        const allLabels = [crossSectionLabel, crossSectionOutLabel, pathLabel, volumeLabel, pointRLabel, omegaLabel,
                          ...incomingLabels, ...targetLabels];

        // Animation system
        let collisionCount = 0;
        const animatedPhotons = [];
        const flashEffects = [];
        const photonSpeed = 0.015;

        function createAnimatedPhoton(startPos, direction, hostSphere, color) {
            const photonGroup = new THREE.Group();
            
            const sphereGeometry = new THREE.SphereGeometry(0.10, 16, 16);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            photonGroup.add(sphere);
            
            const trailGeometry = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(60);
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            photonGroup.add(trail);
            
            photonGroup.position.copy(startPos);
            
            return {
                group: photonGroup,
                startPos: startPos.clone(),
                currentPos: startPos.clone(),
                direction: direction.normalize(),
                hostSphere: hostSphere,
                inscattered: false,
                inscatteredPhoton: null,
                collisionLogged: false,
                trailPositions: [],
                active: true,
                velocity: 1.0,
                color: color
            };
        }

        function createFlash(position) {
            const flashGroup = new THREE.Group();
            
            const flashGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                transparent: true,
                opacity: 1.0
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flashGroup.add(flash);
            
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FF00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            flashGroup.add(ring);
            
            const flashLight = new THREE.PointLight(0x00FF00, 1.0, 2);
            flashGroup.add(flashLight);
            
            flashGroup.position.copy(position);
            scene.add(flashGroup);
            
            flashEffects.push({
                group: flashGroup,
                flash: flash,
                ring: ring,
                light: flashLight,
                time: 0,
                maxTime: 0.6,
                maxScale: 1.8
            });
        }

        function initializeAnimatedPhotons() {
            animatedPhotons.forEach(p => {
                scene.remove(p.group);
                if (p.inscatteredPhoton) scene.remove(p.inscatteredPhoton);
            });
            animatedPhotons.length = 0;
            
            const numPhotons = 15;
            const incomingColors = [0xFF00FF, 0x00FFFF, 0xFFFF00, 0xFF8800, 0xFF0088, 0x88FF00];
            
            for (let i = 0; i < numPhotons; i++) {
                const theta = (i / numPhotons) * Math.PI;
                const phi = (i / numPhotons) * 2 * Math.PI;
                
                const incomingDir = new THREE.Vector3(
                    Math.sin(theta) * Math.cos(phi),
                    Math.sin(theta) * Math.sin(phi),
                    Math.cos(theta)
                ).normalize();
                
                const hostSphere = hostMaterialSpheres[Math.floor(Math.random() * hostMaterialSpheres.length)];
                
                const startDist = 3.0;
                const startPos = hostSphere.position.clone().add(incomingDir.clone().multiplyScalar(-startDist));
                
                const color = incomingColors[i % incomingColors.length];
                
                const photon = createAnimatedPhoton(startPos, incomingDir, hostSphere, color);
                animatedPhotons.push(photon);
                scene.add(photon.group);
            }
        }

        function updatePhotonAnimation(deltaTime) {
            animatedPhotons.forEach(photon => {
                if (!photon.active) return;
                
                if (!photon.inscattered && photon.velocity > 0) {
                    photon.currentPos.add(photon.direction.clone().multiplyScalar(photonSpeed * photon.velocity));
                    photon.group.position.copy(photon.currentPos);
                    
                    photon.trailPositions.push(photon.currentPos.clone());
                    if (photon.trailPositions.length > 20) {
                        photon.trailPositions.shift();
                    }
                    
                    const positions = photon.group.children[1].geometry.attributes.position.array;
                    for (let i = 0; i < photon.trailPositions.length; i++) {
                        positions[i * 3] = photon.trailPositions[i].x;
                        positions[i * 3 + 1] = photon.trailPositions[i].y;
                        positions[i * 3 + 2] = photon.trailPositions[i].z;
                    }
                    photon.group.children[1].geometry.attributes.position.needsUpdate = true;
                    
                    if (photon.hostSphere && !photon.collisionLogged) {
                        const distToHost = photon.currentPos.distanceTo(photon.hostSphere.position);
                        
                        if (distToHost < 0.25) {
                            createFlash(photon.hostSphere.position.clone());
                            photon.inscattered = true;
                            photon.collisionLogged = true;
                            collisionCount++;
                            
                            console.log(`Inscattering ${collisionCount}!`);
                            
                            scene.remove(photon.group);
                            
                            const greenPhoton = createParticleWithSphere(
                                photon.hostSphere.position.clone(),
                                omegaDirection,
                                1.5,
                                0x00FF00,
                                0.10
                            );
                            photon.inscatteredPhoton = greenPhoton;
                            scene.add(greenPhoton);
                        }
                    }
                }
            });
            
            for (let i = flashEffects.length - 1; i >= 0; i--) {
                const flash = flashEffects[i];
                flash.time += deltaTime;
                const progress = flash.time / flash.maxTime;
                
                if (progress >= 1.0) {
                    scene.remove(flash.group);
                    flashEffects.splice(i, 1);
                } else {
                    const scale = 1.0 + (flash.maxScale - 1.0) * progress;
                    flash.flash.scale.set(scale, scale, scale);
                    flash.ring.scale.set(scale, scale, scale);
                    flash.flash.material.opacity = 1.0 - progress;
                    flash.ring.material.opacity = 0.8 * (1.0 - progress);
                    flash.light.intensity = 1.0 * (1.0 - progress);
                }
            }
            
            const allDone = animatedPhotons.every(p => 
                !p.active || 
                p.inscattered ||
                (p.currentPos.distanceTo(p.startPos) > 5.0)
            );
            
            if (allDone && animatedPhotons.length > 0) {
                console.log(`Animation cycle complete. Total inscattering events: ${collisionCount}`);
                
                const animationEnabled = document.getElementById('enableAnimation').checked;
                
                if (animationEnabled) {
                    setTimeout(() => {
                        animatedPhotons.forEach(p => {
                            scene.remove(p.group);
                            if (p.inscatteredPhoton) scene.remove(p.inscatteredPhoton);
                        });
                        animatedPhotons.length = 0;
                        flashEffects.forEach(f => scene.remove(f.group));
                        flashEffects.length = 0;
                        collisionCount = 0;
                        
                        if (document.getElementById('enableAnimation').checked) {
                            initializeAnimatedPhotons();
                        }
                    }, 1500);
                }
            }
        }

        // Event listeners
        document.getElementById('showVolume').addEventListener('change', (e) => {
            volumeElement.visible = e.target.checked;
            crossSection.visible = e.target.checked;
            crossSectionEdges.visible = e.target.checked;
            crossSectionLabel.visible = e.target.checked;
            crossSectionOut.visible = e.target.checked;
            crossSectionOutEdges.visible = e.target.checked;
            crossSectionOutLabel.visible = e.target.checked;
            volumeLabel.visible = e.target.checked;
            pointRLabel.visible = e.target.checked;
        });

        document.getElementById('showPath').addEventListener('change', (e) => {
            markerLine.visible = e.target.checked;
            startTick.visible = e.target.checked;
            endTick.visible = e.target.checked;
            pathLabel.visible = e.target.checked;
            omegaLabel.visible = e.target.checked;
        });

        document.getElementById('showPhotons').addEventListener('change', (e) => {
            targetPhotons.forEach(p => p.visible = e.target.checked);
            targetLabels.forEach(l => l.visible = e.target.checked);
        });

        document.getElementById('showIncoming').addEventListener('change', (e) => {
            incomingPhotons.forEach(p => p.visible = e.target.checked);
            incomingLabels.forEach(l => l.visible = e.target.checked);
        });

        document.getElementById('showHost').addEventListener('change', (e) => {
            hostMaterialSpheres.forEach(s => s.visible = e.target.checked);
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            allLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('enableAnimation').addEventListener('change', (e) => {
            if (e.target.checked) {
                initializeAnimatedPhotons();
            } else {
                animatedPhotons.forEach(p => {
                    scene.remove(p.group);
                    if (p.inscatteredPhoton) scene.remove(p.inscatteredPhoton);
                });
                animatedPhotons.length = 0;
                flashEffects.forEach(f => scene.remove(f.group));
                flashEffects.length = 0;
            }
        });

        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 0, 0);
        });

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                
                const radius = camera.position.length();
                const theta = Math.atan2(camera.position.x, camera.position.z);
                const phi = Math.acos(camera.position.y / radius);
                
                const newTheta = theta + deltaX * rotationSpeed;
                const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * rotationSpeed));
                
                camera.position.x = radius * Math.sin(newPhi) * Math.sin(newTheta);
                camera.position.y = radius * Math.cos(newPhi);
                camera.position.z = radius * Math.sin(newPhi) * Math.cos(newTheta);
                camera.lookAt(0, 0, 0);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = camera.position.clone().normalize();
            const distance = e.deltaY * zoomSpeed;
            
            camera.position.add(direction.multiplyScalar(distance));
            
            const dist = camera.position.length();
            if (dist < 3) {
                camera.position.normalize().multiplyScalar(3);
            } else if (dist > 20) {
                camera.position.normalize().multiplyScalar(20);
            }
        });

        // Animation loop
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updatePhotonAnimation(deltaTime);
            
            allLabels.forEach(label => {
                label.lookAt(camera.position);
            });
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>