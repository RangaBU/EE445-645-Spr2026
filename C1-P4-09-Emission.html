<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photon Emission - 3D Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 220px;
            font-size: 12px;
        }
        h2 {
            margin: 0 0 10px 0;
            color: #1a1a2e;
            font-size: 16px;
            border-bottom: 2px solid #0f3460;
            padding-bottom: 5px;
        }
        label {
            display: block;
            margin: 8px 0 3px 0;
            color: #333;
            font-weight: 600;
            font-size: 12px;
        }
        button {
            width: 100%;
            padding: 8px;
            margin: 6px 0;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s;
        }
        button:hover {
            background: #16213e;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        input[type="checkbox"] {
            margin-right: 6px;
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            font-size: 11px;
            max-width: 280px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-color {
            width: 30px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 340px;
            font-size: 11px;
            line-height: 1.7;
        }
        .equation {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.6;
        }
        .vector {
            font-weight: bold;
            position: relative;
            display: inline-block;
        }
        .vector::after {
            content: '→';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: bold;
        }
        .section-label {
            font-weight: bold;
            color: #0f3460;
            margin-top: 12px;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .highlight {
            background: #fffacd;
            padding: 2px 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>Controls</h2>
        <div class="checkbox-container">
            <input type="checkbox" id="showVolume" checked>
            <label for="showVolume">Show Volume Element</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showPath" checked>
            <label for="showPath">Show Path Δξ</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showSolidAngle" checked>
            <label for="showSolidAngle">Show Solid Angle Δ<span class="vector">Ω</span></label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showPhotons" checked>
            <label for="showPhotons">Show Photons</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showHost" checked>
            <label for="showHost">Show Host Material</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="showLabels" checked>
            <label for="showLabels">Show Labels</label>
        </div>
        <div class="checkbox-container">
            <input type="checkbox" id="enableAnimation">
            <label for="enableAnimation">Enable Animation</label>
        </div>
        <button id="resetView">Reset View</button>
    </div>

    <div id="info">
        <h2 style="font-size: 14px; margin-top: 0;">Photon Emission (Gain)</h2>
        
        <div class="section-label">Volume Element at point <span class="vector">r</span>:</div>
        <div class="equation">
            Δ<span class="vector">r</span> = ΔS Δξ
        </div>
        <p style="margin: 4px 0; color: #555; font-size: 10px;">
            ΔS: cross-sectional area<br>
            Δξ: pathlength
        </p>
        
        <div class="section-label">Photons Emitted (Gained):</div>
        <p style="margin: 4px 0; color: #333; font-size: 11px;">
            • Frequency interval: (ν, ν+Δν)<br>
            • Direction: <span class="vector">Ω</span><br>
            • Solid angle: Δ<span class="vector">Ω</span><br>
            • Over pathlength: Δξ<br>
            • Time interval: Δt
        </p>
        
        <div class="section-label">Number of Photons Emitted:</div>
        <div class="equation">
            dN<sub>E</sub>(<span class="vector">r</span>, ν, <span class="vector">Ω</span>, t) = 
            <br>
            q(<span class="vector">r</span>, ν, <span class="vector">Ω</span>, t) ΔS Δξ Δν Δ<span class="vector">Ω</span> <span class="highlight">c Δt</span>
        </div>
        
        <p style="margin: 6px 0; color: #333; font-size: 10px;">
            <b>q</b>: emission coefficient<br>
            <b>c</b>: speed of light<br>
            Photons spontaneously created within the volume element
        </p>
    </div>

    <div id="legend">
        <h2 style="font-size: 14px; margin-top: 0;">Legend</h2>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(100, 149, 237, 0.4); border: 2px solid #6495ED;"></div>
            <span>Volume Δ<span class="vector">r</span> = ΔS·Δξ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFFFFF; border: 1px solid #999;"></div>
            <span>Host Material (emitters)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFD700;"></div>
            <span>Pathlength Δξ</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: rgba(255, 215, 0, 0.3); border: 2px solid #FFD700;"></div>
            <span>Solid Angle Δ<span class="vector">Ω</span></span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00FF00;"></div>
            <span>Emitted photons (green)</span>
        </div>
    </div>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(8, 5, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        const backLight = new THREE.DirectionalLight(0x6699ff, 0.4);
        backLight.position.set(-10, -10, -5);
        scene.add(backLight);

        // Define Omega direction
        const omegaDirection = new THREE.Vector3(1, 0.3, 0.2).normalize();
        
        // Volume parameters
        const crossSectionSize = 1.5;
        const deltaXi = 2.0;

        // Helper function to create text labels with arrows above vectors
        function createTextLabel(text, position, color, size = 40, hasArrow = false, arrowOverChar = null) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            context.fillStyle = color;
            context.font = `Bold ${size}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 128, 74);
            
            // Draw arrow above if it's a vector
            if (hasArrow) {
                context.font = `Bold ${size * 0.6}px Arial`;
                let arrowX = 128;
                
                // If specific character position is given, calculate offset
                if (arrowOverChar !== null && arrowOverChar < text.length) {
                    // Measure text width up to the character
                    context.font = `Bold ${size}px Arial`;
                    const beforeText = text.substring(0, arrowOverChar);
                    const charText = text.charAt(arrowOverChar);
                    const beforeWidth = context.measureText(beforeText).width;
                    const charWidth = context.measureText(charText).width;
                    
                    // Calculate position: center of canvas minus half text width, plus position to character center
                    const textWidth = context.measureText(text).width;
                    arrowX = 128 - textWidth/2 + beforeWidth + charWidth/2;
                }
                
                context.font = `Bold ${size * 0.6}px Arial`;
                context.fillText('→', arrowX, 35);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(2, 1, 1);
            
            return sprite;
        }

        // Create cross-section at entry (ΔS)
        const crossSectionGeometry = new THREE.PlaneGeometry(crossSectionSize, crossSectionSize);
        const crossSectionMaterial = new THREE.MeshPhongMaterial({
            color: 0x6495ED,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const crossSection = new THREE.Mesh(crossSectionGeometry, crossSectionMaterial);
        
        // Position and orient cross-section perpendicular to Omega
        const axis = new THREE.Vector3(0, 0, 1);
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(axis, omegaDirection);
        crossSection.quaternion.copy(quaternion);
        crossSection.position.set(0, 0, 0);
        scene.add(crossSection);

        // Add edges to cross-section
        const crossSectionEdges = new THREE.EdgesGeometry(crossSectionGeometry);
        const crossSectionLines = new THREE.LineSegments(
            crossSectionEdges,
            new THREE.LineBasicMaterial({ color: 0x6495ED, linewidth: 2 })
        );
        crossSectionLines.quaternion.copy(quaternion);
        crossSectionLines.position.set(0, 0, 0);
        scene.add(crossSectionLines);

        // Create cross-section at exit
        const crossSectionOut = new THREE.Mesh(crossSectionGeometry, crossSectionMaterial);
        const exitPos = omegaDirection.clone().multiplyScalar(deltaXi);
        crossSectionOut.quaternion.copy(quaternion);
        crossSectionOut.position.copy(exitPos);
        scene.add(crossSectionOut);

        const crossSectionOutEdges = new THREE.LineSegments(
            crossSectionEdges,
            new THREE.LineBasicMaterial({ color: 0x6495ED, linewidth: 2 })
        );
        crossSectionOutEdges.quaternion.copy(quaternion);
        crossSectionOutEdges.position.copy(exitPos);
        scene.add(crossSectionOutEdges);

        // Create volume element connecting the cross-sections
        const volumeElement = new THREE.Group();
        
        // Create connecting lines for volume visualization
        const corners = [
            new THREE.Vector3(-crossSectionSize/2, -crossSectionSize/2, 0),
            new THREE.Vector3(crossSectionSize/2, -crossSectionSize/2, 0),
            new THREE.Vector3(crossSectionSize/2, crossSectionSize/2, 0),
            new THREE.Vector3(-crossSectionSize/2, crossSectionSize/2, 0)
        ];

        corners.forEach(corner => {
            const startCorner = corner.clone().applyQuaternion(quaternion);
            const endCorner = corner.clone().applyQuaternion(quaternion).add(exitPos);
            
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([startCorner, endCorner]);
            const line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({ 
                color: 0x6495ED, 
                linewidth: 1,
                transparent: true,
                opacity: 0.6
            }));
            volumeElement.add(line);
        });
        
        scene.add(volumeElement);

        // Create solid angle cone (narrow cone showing ΔΩ)
        const coneAngle = 0.2;
        const coneHeight = 3.5;
        const coneRadius = coneHeight * Math.tan(coneAngle);
        
        const coneGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 32, 1, true);
        const coneMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFD700,
            transparent: true,
            opacity: 0.25,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const solidAngleCone = new THREE.Mesh(coneGeometry, coneMaterial);

        // Position cone - base at origin, extending in omega direction
        const defaultDirection = new THREE.Vector3(0, -1, 0);
        const coneQuaternion = new THREE.Quaternion();
        coneQuaternion.setFromUnitVectors(defaultDirection, omegaDirection);
        solidAngleCone.quaternion.copy(coneQuaternion);
        
        const offset = new THREE.Vector3(0, -coneHeight / 2, 0);
        offset.applyQuaternion(coneQuaternion);
        solidAngleCone.position.add(offset);
        scene.add(solidAngleCone);

        // Add cone edges
        const coneEdgesGeometry = new THREE.EdgesGeometry(coneGeometry);
        const coneEdges = new THREE.LineSegments(
            coneEdgesGeometry,
            new THREE.LineBasicMaterial({ color: 0xFFD700, linewidth: 2 })
        );
        solidAngleCone.add(coneEdges);

        // Create path marker (Δξ)
        const pathStart = new THREE.Vector3(0, 0, 0);
        const pathEnd = omegaDirection.clone().multiplyScalar(deltaXi);
        const markerLineGeometry = new THREE.BufferGeometry().setFromPoints([pathStart, pathEnd]);
        const markerLine = new THREE.Line(markerLineGeometry, new THREE.LineBasicMaterial({ 
            color: 0xFFD700, 
            linewidth: 3 
        }));
        scene.add(markerLine);

        // Add tick marks at start and end
        const tickSize = 0.2;
        const perpVector1 = new THREE.Vector3(-omegaDirection.y, omegaDirection.x, 0).normalize().multiplyScalar(tickSize);
        const perpVector2 = new THREE.Vector3(0, -omegaDirection.z, omegaDirection.y).normalize().multiplyScalar(tickSize);
        
        // Start tick
        const startTickGeometry = new THREE.BufferGeometry().setFromPoints([
            pathStart.clone().add(perpVector1),
            pathStart.clone().sub(perpVector1)
        ]);
        const startTick = new THREE.Line(startTickGeometry, new THREE.LineBasicMaterial({ color: 0xFFD700, linewidth: 2 }));
        scene.add(startTick);
        
        // End tick
        const endTickGeometry = new THREE.BufferGeometry().setFromPoints([
            pathEnd.clone().add(perpVector1),
            pathEnd.clone().sub(perpVector1)
        ]);
        const endTick = new THREE.Line(endTickGeometry, new THREE.LineBasicMaterial({ color: 0xFFD700, linewidth: 2 }));
        scene.add(endTick);

        // Create Omega direction arrow
        const omegaArrow = new THREE.ArrowHelper(
            omegaDirection,
            new THREE.Vector3(0, 0, 0),
            deltaXi + 0.5,
            0xFF6600,
            0.4,
            0.25
        );
        scene.add(omegaArrow);

        // Add host material particles
        const hostMaterialSpheres = [];
        const particleGeometry = new THREE.SphereGeometry(0.04, 8, 8);
        const particleMaterial = new THREE.MeshPhongMaterial({ color: 0xCCCCCC });
        
        for (let i = 0; i < 40; i++) {
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Distribute particles within the volume
            const t = Math.random();
            const localPos = new THREE.Vector3(
                (Math.random() - 0.5) * crossSectionSize * 0.8,
                (Math.random() - 0.5) * crossSectionSize * 0.8,
                0
            ).applyQuaternion(quaternion);
            
            particle.position.copy(localPos.add(omegaDirection.clone().multiplyScalar(t * deltaXi)));
            hostMaterialSpheres.push(particle);
            scene.add(particle);
        }

        // Create emitted photons (static display)
        const emittedPhotons = [];
        const emittedLabels = [];
        
        for (let i = 0; i < 8; i++) {
            const t = Math.random();
            const localPos = new THREE.Vector3(
                (Math.random() - 0.5) * crossSectionSize * 0.6,
                (Math.random() - 0.5) * crossSectionSize * 0.6,
                0
            ).applyQuaternion(quaternion);
            
            const emissionPos = localPos.add(omegaDirection.clone().multiplyScalar(t * deltaXi));
            
            // Create green photon
            const photonGeometry = new THREE.SphereGeometry(0.08, 12, 12);
            const photonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00FF00,
                emissive: 0x00FF00,
                emissiveIntensity: 0.4
            });
            const photon = new THREE.Mesh(photonGeometry, photonMaterial);
            photon.position.copy(emissionPos);
            
            emittedPhotons.push(photon);
            scene.add(photon);
            
            // Add arrow showing emission direction (within solid angle)
            const emissionDir = omegaDirection.clone().add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.15
            )).normalize();
            
            const photonArrow = new THREE.ArrowHelper(
                emissionDir,
                emissionPos,
                0.6,
                0x00FF00,
                0.15,
                0.1
            );
            emittedPhotons.push(photonArrow);
            scene.add(photonArrow);
        }

        // Labels
        const crossSectionLabel = createTextLabel('ΔS', new THREE.Vector3(-0.9, -0.9, 0).applyQuaternion(quaternion), '#6495ED', 35, false, null);
        scene.add(crossSectionLabel);
        
        const crossSectionOutLabel = createTextLabel('ΔS', exitPos.clone().add(new THREE.Vector3(-0.9, -0.9, 0).applyQuaternion(quaternion)), '#6495ED', 35, false, null);
        scene.add(crossSectionOutLabel);
        
        const pathLabel = createTextLabel('Δξ', omegaDirection.clone().multiplyScalar(deltaXi/2).add(new THREE.Vector3(0, -0.5, 0)), '#FFD700', 40, false, null);
        scene.add(pathLabel);
        
        const volumeLabel = createTextLabel('Δr = ΔS·Δξ', omegaDirection.clone().multiplyScalar(deltaXi/2).add(new THREE.Vector3(0, 0.8, 0)), '#6495ED', 35, true, 1);
        scene.add(volumeLabel);
        
        const pointRLabel = createTextLabel('r', new THREE.Vector3(0.3, 0.3, 0.3), '#FFFFFF', 35, true, 0);
        scene.add(pointRLabel);
        
        const omegaLabel = createTextLabel('Ω', omegaDirection.clone().multiplyScalar(deltaXi + 0.8), '#FF6600', 40, true, 0);
        scene.add(omegaLabel);
        
        const solidAngleLabel = createTextLabel('ΔΩ', omegaDirection.clone().multiplyScalar(2.5).add(new THREE.Vector3(0.5, 0.5, 0)), '#FFD700', 35, true, 1);
        scene.add(solidAngleLabel);

        const allLabels = [crossSectionLabel, crossSectionOutLabel, pathLabel, volumeLabel, pointRLabel, omegaLabel, solidAngleLabel, ...emittedLabels];

        // Animation variables
        let animatedPhotons = [];
        let flashEffects = [];
        let emissionCount = 0;

        function initializeAnimatedPhotons() {
            animatedPhotons = [];
            
            for (let i = 0; i < 6; i++) {
                const t = Math.random();
                const localPos = new THREE.Vector3(
                    (Math.random() - 0.5) * crossSectionSize * 0.6,
                    (Math.random() - 0.5) * crossSectionSize * 0.6,
                    0
                ).applyQuaternion(quaternion);
                
                const emissionPos = localPos.add(omegaDirection.clone().multiplyScalar(t * deltaXi));
                
                animatedPhotons.push({
                    position: emissionPos,
                    emitTime: Math.random() * 2.0,
                    emitted: false,
                    photon: null
                });
            }
        }

        function createFlashEffect(position) {
            const group = new THREE.Group();
            
            // Central flash
            const flashGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FF00,
                transparent: true,
                opacity: 1.0
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            group.add(flash);
            
            // Expanding ring
            const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FF00,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            group.add(ring);
            
            // Light pulse
            const light = new THREE.PointLight(0x00FF00, 1.0, 2);
            group.add(light);
            
            group.position.copy(position);
            scene.add(group);
            
            flashEffects.push({
                group: group,
                flash: flash,
                ring: ring,
                light: light,
                time: 0,
                maxTime: 0.5,
                maxScale: 3.0
            });
        }

        function updatePhotonAnimation(deltaTime) {
            if (animatedPhotons.length === 0) return;
            
            const photonSpeed = 0.8;
            
            animatedPhotons.forEach(emission => {
                if (!emission.emitted) {
                    emission.emitTime -= deltaTime;
                    
                    if (emission.emitTime <= 0 && !emission.emitted) {
                        emission.emitted = true;
                        
                        createFlashEffect(emission.position);
                        
                        // Create animated photon
                        const photonGroup = new THREE.Group();
                        
                        const photonGeometry = new THREE.SphereGeometry(0.1, 12, 12);
                        const photonMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0x00FF00,
                            emissive: 0x00FF00,
                            emissiveIntensity: 0.5
                        });
                        const photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                        photonGroup.add(photonSphere);
                        
                        // Trail
                        const trailGeometry = new THREE.BufferGeometry();
                        const positions = new Float32Array(20 * 3);
                        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        const trailMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x00FF00,
                            transparent: true,
                            opacity: 0.6
                        });
                        const trail = new THREE.Line(trailGeometry, trailMaterial);
                        photonGroup.add(trail);
                        
                        scene.add(photonGroup);
                        
                        emission.photon = {
                            group: photonGroup,
                            startPos: emission.position.clone(),
                            currentPos: emission.position.clone(),
                            trailPositions: [],
                            velocity: 1.0,
                            active: true
                        };
                        
                        emissionCount++;
                    }
                }
                
                if (emission.emitted && emission.photon && emission.photon.active) {
                    const photon = emission.photon;
                    
                    if (photon.velocity > 0) {
                        photon.currentPos.add(omegaDirection.clone().multiplyScalar(photonSpeed * photon.velocity));
                        photon.group.position.copy(photon.currentPos);
                        
                        photon.trailPositions.push(photon.currentPos.clone());
                        if (photon.trailPositions.length > 20) {
                            photon.trailPositions.shift();
                        }
                        
                        const positions = photon.group.children[1].geometry.attributes.position.array;
                        for (let i = 0; i < photon.trailPositions.length; i++) {
                            positions[i * 3] = photon.trailPositions[i].x;
                            positions[i * 3 + 1] = photon.trailPositions[i].y;
                            positions[i * 3 + 2] = photon.trailPositions[i].z;
                        }
                        photon.group.children[1].geometry.attributes.position.needsUpdate = true;
                        
                        const distTraveled = photon.currentPos.distanceTo(photon.startPos);
                        if (distTraveled > deltaXi + 1.5) {
                            setTimeout(() => {
                                photon.active = false;
                                scene.remove(photon.group);
                            }, 1000);
                        }
                    }
                }
            });
            
            for (let i = flashEffects.length - 1; i >= 0; i--) {
                const flash = flashEffects[i];
                flash.time += deltaTime;
                const progress = flash.time / flash.maxTime;
                
                if (progress >= 1.0) {
                    scene.remove(flash.group);
                    flashEffects.splice(i, 1);
                } else {
                    const scale = 1.0 + (flash.maxScale - 1.0) * progress;
                    flash.flash.scale.set(scale, scale, scale);
                    flash.ring.scale.set(scale, scale, scale);
                    flash.flash.material.opacity = 1.0 - progress;
                    flash.ring.material.opacity = 0.8 * (1.0 - progress);
                    flash.light.intensity = 1.0 * (1.0 - progress);
                }
            }
            
            const allDone = animatedPhotons.every(e => 
                e.emitted && (!e.photon || !e.photon.active || 
                (e.photon.currentPos.distanceTo(e.photon.startPos) > deltaXi + 2.0))
            );
            
            if (allDone && animatedPhotons.length > 0) {
                const animationEnabled = document.getElementById('enableAnimation').checked;
                
                if (animationEnabled) {
                    setTimeout(() => {
                        animatedPhotons.forEach(e => {
                            if (e.photon) scene.remove(e.photon.group);
                        });
                        animatedPhotons.length = 0;
                        flashEffects.forEach(f => scene.remove(f.group));
                        flashEffects.length = 0;
                        emissionCount = 0;
                        
                        if (document.getElementById('enableAnimation').checked) {
                            initializeAnimatedPhotons();
                        }
                    }, 1500);
                }
            }
        }

        // Event listeners
        document.getElementById('showVolume').addEventListener('change', (e) => {
            volumeElement.visible = e.target.checked;
            crossSection.visible = e.target.checked;
            crossSectionLines.visible = e.target.checked;
            crossSectionLabel.visible = e.target.checked;
            crossSectionOut.visible = e.target.checked;
            crossSectionOutEdges.visible = e.target.checked;
            crossSectionOutLabel.visible = e.target.checked;
            volumeLabel.visible = e.target.checked;
            pointRLabel.visible = e.target.checked;
        });

        document.getElementById('showPath').addEventListener('change', (e) => {
            markerLine.visible = e.target.checked;
            startTick.visible = e.target.checked;
            endTick.visible = e.target.checked;
            pathLabel.visible = e.target.checked;
            omegaArrow.visible = e.target.checked;
            omegaLabel.visible = e.target.checked;
        });

        document.getElementById('showSolidAngle').addEventListener('change', (e) => {
            solidAngleCone.visible = e.target.checked;
            solidAngleLabel.visible = e.target.checked;
        });

        document.getElementById('showPhotons').addEventListener('change', (e) => {
            emittedPhotons.forEach(p => p.visible = e.target.checked);
        });

        document.getElementById('showHost').addEventListener('change', (e) => {
            hostMaterialSpheres.forEach(s => s.visible = e.target.checked);
        });

        document.getElementById('showLabels').addEventListener('change', (e) => {
            allLabels.forEach(label => label.visible = e.target.checked);
        });

        document.getElementById('enableAnimation').addEventListener('change', (e) => {
            if (e.target.checked) {
                initializeAnimatedPhotons();
            } else {
                animatedPhotons.forEach(e => {
                    if (e.photon) scene.remove(e.photon.group);
                });
                animatedPhotons.length = 0;
                flashEffects.forEach(f => scene.remove(f.group));
                flashEffects.length = 0;
            }
        });

        document.getElementById('resetView').addEventListener('click', () => {
            camera.position.set(8, 5, 8);
            camera.lookAt(0, 0, 0);
        });

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                
                const radius = camera.position.length();
                const theta = Math.atan2(camera.position.x, camera.position.z);
                const phi = Math.acos(camera.position.y / radius);
                
                const newTheta = theta + deltaX * rotationSpeed;
                const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * rotationSpeed));
                
                camera.position.x = radius * Math.sin(newPhi) * Math.sin(newTheta);
                camera.position.y = radius * Math.cos(newPhi);
                camera.position.z = radius * Math.sin(newPhi) * Math.cos(newTheta);
                camera.lookAt(0, 0, 0);
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = camera.position.clone().normalize();
            const distance = e.deltaY * zoomSpeed;
            
            camera.position.add(direction.multiplyScalar(distance));
            
            const dist = camera.position.length();
            if (dist < 3) {
                camera.position.normalize().multiplyScalar(3);
            } else if (dist > 20) {
                camera.position.normalize().multiplyScalar(20);
            }
        });

        // Animation loop
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updatePhotonAnimation(deltaTime);
            
            allLabels.forEach(label => {
                label.lookAt(camera.position);
            });
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
