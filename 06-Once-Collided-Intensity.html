<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Once-Scattered Intensity</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; overflow: hidden; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; }
        
        .vec { position: relative; display: inline-block; }
        .vec::after {
            content: 'â†’';
            position: absolute;
            top: -0.7em;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border: 2px solid #4488ff;
            border-radius: 5px;
            font-size: 12px;
            max-width: 320px;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border: 2px solid #4488ff;
            border-radius: 5px;
            min-width: 250px;
        }
        
        #speedSlider { width: 100%; margin: 10px 0; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h3 style="color: #4488ff; margin-bottom: 10px;">Animation Controls</h3>
        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
            <span>Speed:</span>
            <span id="speedValue">1.0x</span>
        </div>
        <input type="range" id="speedSlider" min="0.1" max="3.0" step="0.1" value="1.0">
        <div style="margin-top: 10px; color: #aaa;">
            Source <span id="currentSource">1</span> of <span id="totalSources">8</span>
        </div>
    </div>
    
    <div id="info">
        <h3 style="color: #4488ff; margin-bottom: 10px;">
            Once-Scattered Intensity IÂ¹(<span class="vec">r</span>,<span class="vec">Î©</span>)
        </h3>
        <div style="margin: 5px 0;">ðŸŸ§ Boundary Surface</div>
        <div style="margin: 5px 0;">âšª Host Material</div>
        <div style="margin: 5px 0;">ðŸŸ¢ Observation Point <span class="vec">r</span></div>
        <div style="margin: 5px 0;">ðŸ”µ Direction <span class="vec">Î©</span></div>
        <div style="margin: 5px 0;">ðŸ”´ Active Source QÂ¹</div>
        <div style="margin: 5px 0;">ðŸŸ£ Integration Path</div>
        <div style="margin-top: 10px; color: #aaa; font-size: 11px;">
            Blue photons shoot from red sources toward green point
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-8, 3, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        let animationSpeed = 1.0;
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const light1 = new THREE.DirectionalLight(0xffffff, 1.0);
        light1.position.set(10, 10, 10);
        scene.add(light1);

        const a = 3, b = 2, c = 1.5;

        for (let i = 0; i < 24; i++) {
            const theta = (i / 24) * Math.PI * 2;
            const points = [];
            for (let j = 0; j <= 50; j++) {
                const phi = (j / 50) * Math.PI;
                points.push(new THREE.Vector3(
                    a * Math.sin(phi) * Math.cos(theta),
                    b * Math.sin(phi) * Math.sin(theta),
                    c * Math.cos(phi)
                ));
            }
            scene.add(new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({ color: 0xff8800 })
            ));
        }

        for (let j = 0; j <= 16; j++) {
            const phi = (j / 16) * Math.PI;
            const points = [];
            for (let i = 0; i <= 100; i++) {
                const theta = (i / 100) * Math.PI * 2;
                points.push(new THREE.Vector3(
                    a * Math.sin(phi) * Math.cos(theta),
                    b * Math.sin(phi) * Math.sin(theta),
                    c * Math.cos(phi)
                ));
            }
            scene.add(new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(points),
                new THREE.LineBasicMaterial({ color: 0xff8800 })
            ));
        }

        for (let i = 0; i < 80; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = Math.pow(Math.random(), 1/3) * 0.85;
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 20, 20),
                new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, metalness: 0, roughness: 0.3,
                    emissive: 0xffffff, emissiveIntensity: 0.3
                })
            );
            particle.position.set(
                r * a * Math.sin(phi) * Math.cos(theta),
                r * b * Math.sin(phi) * Math.sin(theta),
                r * c * Math.cos(phi)
            );
            scene.add(particle);
        }

        const r_obs = new THREE.Vector3(0.2, 0.15, 0.1);
        const omega = new THREE.Vector3(-0.6, -0.4, 0.5).normalize();
        
        function findBoundary(origin, direction) {
            const d = direction, o = origin;
            const A = (d.x*d.x)/(a*a) + (d.y*d.y)/(b*b) + (d.z*d.z)/(c*c);
            const B = 2*((o.x*d.x)/(a*a) + (o.y*d.y)/(b*b) + (o.z*d.z)/(c*c));
            const C = (o.x*o.x)/(a*a) + (o.y*o.y)/(b*b) + (o.z*o.z)/(c*c) - 1;
            const disc = B*B - 4*A*C;
            const t = Math.max((-B + Math.sqrt(disc))/(2*A), (-B - Math.sqrt(disc))/(2*A));
            return origin.clone().add(direction.clone().multiplyScalar(t));
        }
        
        const r_B = findBoundary(r_obs, omega.clone().negate());

        const obsPoint = new THREE.Mesh(
            new THREE.SphereGeometry(0.20, 24, 24),
            new THREE.MeshStandardMaterial({ 
                color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0
            })
        );
        obsPoint.position.copy(r_obs);
        scene.add(obsPoint);

        const boundPoint = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 24, 24),
            new THREE.MeshStandardMaterial({ 
                color: 0xff8800, emissive: 0xff8800, emissiveIntensity: 0.8
            })
        );
        boundPoint.position.copy(r_B);
        scene.add(boundPoint);

        scene.add(new THREE.ArrowHelper(omega, r_obs, 1.5, 0x4488ff, 0.25, 0.2));

        const pathLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([r_obs, r_B]),
            new THREE.LineDashedMaterial({ color: 0xff00ff, linewidth: 2, dashSize: 0.3, gapSize: 0.15 })
        );
        pathLine.computeLineDistances();
        scene.add(pathLine);

        // Create sprites with arrows CLOSER to characters
        function createTextSprite(mainChar, subscript, color, showArrow = true) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = color;
            context.textAlign = 'center';
            
            if (showArrow) {
                // Arrow positioned CLOSER to character - reduced gap
                context.font = 'Bold 60px Arial';
                context.fillText('â†’', canvas.width / 2, 110); // Was 80, now 110 (30 pixels closer)
            }
            
            context.font = 'Bold 80px Arial';
            context.fillText(mainChar, canvas.width / 2, 160);
            
            if (subscript) {
                context.font = 'Bold 50px Arial';
                context.fillText(subscript, canvas.width / 2 + 60, 180);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(1.2, 0.6, 1);
            
            return sprite;
        }

        // Create Q label with arrows CLOSER to characters
        function createQLabel(color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1200;
            canvas.height = 300;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = color;
            context.textAlign = 'left';
            
            let x = 100;
            const y = 180;
            const arrowY = 130; // Was 100, now 130 (30 pixels closer to characters)
            
            // QÂ¹(
            context.font = 'Bold 60px Arial';
            context.fillText('QÂ¹(', x, y);
            x += 120;
            
            // r with arrow CLOSER ON TOP
            context.font = 'Bold 50px Arial';
            context.fillText('â†’', x + 15, arrowY);
            context.font = 'Bold 60px Arial';
            context.fillText('r', x, y);
            x += 50;
            
            // -s'
            context.fillText('-s\'', x, y);
            x += 100;
            
            // Î© with arrow CLOSER ON TOP
            context.font = 'Bold 50px Arial';
            context.fillText('â†’', x + 20, arrowY);
            context.font = 'Bold 60px Arial';
            context.fillText('Î©', x, y);
            x += 80;
            
            // ,
            context.fillText(',', x, y);
            x += 40;
            
            // Î© with arrow CLOSER ON TOP
            context.font = 'Bold 50px Arial';
            context.fillText('â†’', x + 20, arrowY);
            context.font = 'Bold 60px Arial';
            context.fillText('Î©', x, y);
            x += 80;
            
            // )
            context.fillText(')', x, y);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(3.6, 0.9, 1);
            
            return sprite;
        }

        // Add labels with arrows closer to characters
        const labelR = createTextSprite('r', '', '#00ff00', true);
        labelR.position.set(r_obs.x + 0.4, r_obs.y + 0.35, r_obs.z + 0.2);
        scene.add(labelR);

        const labelOmega = createTextSprite('Î©', '', '#4488ff', true);
        const omegaEnd = r_obs.clone().add(omega.clone().multiplyScalar(1.5));
        labelOmega.position.set(omegaEnd.x + 0.8, omegaEnd.y + 0.8, omegaEnd.z + 0.5);
        scene.add(labelOmega);

        const labelRB = createTextSprite('r', '_B', '#ff8800', true);
        labelRB.position.set(r_B.x + 0.5, r_B.y + 0.4, r_B.z + 0.3);
        scene.add(labelRB);

        const labelQ = createQLabel('#ff0000');
        const midPath = r_obs.clone().lerp(r_B, 0.5);
        labelQ.position.set(midPath.x + 0.2, midPath.y + 0.9, midPath.z + 0.4);
        scene.add(labelQ);

        const numSources = 8;
        const sourcePositions = [];
        for (let i = 0; i < numSources; i++) {
            sourcePositions.push(r_obs.clone().lerp(r_B, (i + 1) / (numSources + 1)));
        }
        document.getElementById('totalSources').textContent = numSources;

        let currentSource = 0;
        let activeSourceMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 20, 20),
            new THREE.MeshStandardMaterial({ 
                color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.2
            })
        );
        activeSourceMesh.position.copy(sourcePositions[0]);
        scene.add(activeSourceMesh);

        const photons = [];
        for (let i = 0; i < 10; i++) {
            const photon = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 16, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x0088ff,
                    emissive: 0x0088ff,
                    emissiveIntensity: 3.0,
                    transparent: true,
                    opacity: 1.0
                })
            );
            photon.visible = false;
            scene.add(photon);
            photons.push(photon);
        }

        let time = 0;
        const cycleTime = 3.0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            time += (1/60) * animationSpeed;
            const totalPhase = time / cycleTime;
            const sourceIndex = Math.floor(totalPhase) % numSources;
            const phase = totalPhase % 1.0;
            
            if (sourceIndex !== currentSource) {
                currentSource = sourceIndex;
                activeSourceMesh.position.copy(sourcePositions[currentSource]);
                document.getElementById('currentSource').textContent = (currentSource + 1);
                photons.forEach(p => p.visible = false);
            }
            
            activeSourceMesh.material.emissiveIntensity = 1.0 + 0.5 * Math.sin(time * 6);
            
            const photonsToShow = Math.floor(phase * 8);
            for (let i = 0; i < 8; i++) {
                const photon = photons[i];
                if (i <= photonsToShow) {
                    photon.visible = true;
                    const photonPhase = (phase * 8 - i) / 1.0;
                    const t = Math.max(0, Math.min(1, photonPhase));
                    const sourcePos = sourcePositions[currentSource];
                    photon.position.lerpVectors(sourcePos, r_obs, t);
                    const dist = sourcePos.distanceTo(r_obs);
                    photon.material.opacity = Math.exp(-t * dist * 1.0) * 0.95;
                } else {
                    photon.visible = false;
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('currentSource').textContent = '1';
        animate();
    </script>
</body>
</html>
